// Generated by CoffeeScript 1.6.3
/*
RubyJS Alpha 0.8.0-beta1
Copyright (c) 2012 Sebastian Burkhard
All rights reserved.
http://www.rubyjs.org/LICENSE.txt
*/


(function() {
  var ArrProto, ArrayMethods, Block, BlockArgs, BlockMulti, BlockSingle, EnumerableMethods, HashMethods, NumericMethods, ObjProto, RArray, RCoerce, REnumerable, RFixnum, RHash, RString, RWrapper, RegexpMethods, SortedElement, StrProto, StringMethods, TimeMethods, callFunctionWithThis, dispatchFunction, error, errors, fn, klass, klasses, lookupFunction, method, name, nativeArray, nativeJoin, nativeNumber, nativeObject, nativePush, nativeRegExp, nativeSlice, nativeSort, nativeStrMatch, nativeStrSlice, nativeString, nativeToString, nativeUnshift, previousR, root, __arr, __blockify, __call, __cmp, __cmpstrict, __ensure_args_length, __enumerate, __equals, __extract_block, __falsey, __int, __isArr, __isRgx, __isStr, __num, __rand, __str, __truthy, __try_str, _arr, _coerce, _err, _fn, _fn1, _hsh, _i, _itr, _j, _len, _len1, _num, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _rgx, _str, _time,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.RubyJS = function(obj, recursive, block) {
    return RubyJS.Base.prototype.box(obj, recursive, block);
  };

  RubyJS.VERSION = '0.8.0-beta1';

  if (root.R != null) {
    previousR = root.R;
  }

  RubyJS.noConflict = function() {
    root.R = previousR;
    return RubyJS;
  };

  root.R = RubyJS;

  RubyJS.extend = function(obj, mixin) {
    var method, name;
    for (name in mixin) {
      method = mixin[name];
      obj[name] = method;
    }
    return obj;
  };

  RubyJS.include = function(mixin, replace) {
    var method, name, _ref;
    if (replace == null) {
      replace = false;
    }
    _ref = mixin.prototype;
    for (name in _ref) {
      method = _ref[name];
      if (replace) {
        this.prototype[name] = method;
      } else {
        if (!this.prototype[name]) {
          this.prototype[name] = method;
        }
      }
    }
    return mixin;
  };

  if (typeof exports !== 'undefined') {
    exports.R = R;
    exports.RubyJS = RubyJS;
  }

  R.Support = {
    argify: function() {
      return arguments;
    }
  };

  callFunctionWithThis = function(func) {
    return function(a, b, c, d, e, f) {
      var idx, val;
      idx = arguments.length;
      while (idx--) {
        if (arguments[idx] !== void 0) {
          break;
        }
      }
      val = this.valueOf();
      switch (idx + 1) {
        case 0:
          return func(val);
        case 1:
          return func(val, a);
        case 2:
          return func(val, a, b);
        case 3:
          return func(val, a, b, c);
        case 4:
          return func(val, a, b, c, d);
        case 5:
          return func(val, a, b, c, d, e);
        case 6:
          return func(val, a, b, c, d, e, f);
        default:
          return func.apply(null, [val].concat(nativeSlice.call(arguments, 0)));
      }
    };
  };

  __ensure_args_length = function(args, length) {
    if (args.length !== length) {
      throw R.ArgumentError["new"]();
    }
  };

  __extract_block = function(args) {
    var idx, _ref;
    idx = args.length;
    while (--idx >= 0) {
      if (((_ref = args[idx]) != null ? _ref.call : void 0) != null) {
        return args.pop();
      }
    }
    return null;
  };

  R.Support.callFunctionWithThis = callFunctionWithThis;

  R.Support.ensure_args_length = __ensure_args_length;

  R.Support.extract_block = __extract_block;

  nativeArray = Array;

  nativeNumber = Number;

  nativeObject = Object;

  nativeRegExp = RegExp;

  nativeString = String;

  ObjProto = Object.prototype;

  StrProto = String.prototype;

  ArrProto = Array.prototype;

  nativeToString = ObjProto.toString;

  nativeStrSlice = StrProto.slice;

  nativeStrMatch = StrProto.match;

  nativeJoin = ArrProto.join;

  nativeSort = ArrProto.sort;

  nativeSlice = ArrProto.slice;

  nativeUnshift = ArrProto.unshift;

  nativePush = ArrProto.push;

  Block = (function() {
    function Block() {}

    Block.create = function(block, thisArg) {
      if ((block != null ? block.call : void 0) != null) {
        if (block.length !== 1) {
          return new BlockMulti(block, thisArg);
        } else {
          return new BlockSingle(block, thisArg);
        }
      } else {
        return new BlockArgs(block, thisArg);
      }
    };

    Block.splat_arguments = function(block) {
      if (block.length > 1) {
        return function(item) {
          if (typeof item === 'object' && __isArr(item)) {
            return block.apply(null, item);
          } else {
            return block(item);
          }
        };
      } else {
        return block;
      }
    };

    return Block;

  })();

  BlockArgs = (function() {
    function BlockArgs(block, thisArg) {
      this.block = block;
      this.thisArg = thisArg;
    }

    BlockArgs.prototype.invoke = function(args) {
      return RCoerce.single_block_args(args, this.block);
    };

    return BlockArgs;

  })();

  BlockMulti = (function() {
    function BlockMulti(block, thisArg) {
      this.block = block;
      this.thisArg = thisArg;
    }

    BlockMulti.prototype.args = function(args) {
      if (args.length > 1) {
        return nativeSlice.call(args);
      } else {
        return args[0];
      }
    };

    BlockMulti.prototype.invoke = function(args) {
      var arg;
      if (args.length > 1) {
        return this.block.apply(this.thisArg, args);
      } else {
        arg = args[0];
        if (typeof arg === 'object' && __isArr(arg)) {
          return this.block.apply(this.thisArg, arg);
        } else {
          return this.block.call(this.thisArg, arg);
        }
      }
    };

    BlockMulti.prototype.invokeSplat = function() {
      return this.block.apply(this.thisArg, arguments);
    };

    return BlockMulti;

  })();

  BlockSingle = (function() {
    function BlockSingle(block, thisArg) {
      this.block = block;
      this.thisArg = thisArg;
    }

    BlockSingle.prototype.args = function(args) {
      return args[0];
    };

    BlockSingle.prototype.invoke = function(args) {
      return this.block.call(this.thisArg, args[0]);
    };

    BlockSingle.prototype.invokeSplat = function() {
      return this.block.apply(this.thisArg, arguments);
    };

    return BlockSingle;

  })();

  R.Block = Block;

  R.blockify = __blockify = Block.create;

  RubyJS.Breaker = (function() {
    function Breaker(return_value) {
      this.return_value = return_value != null ? return_value : null;
    }

    Breaker.prototype["break"] = function(return_value) {
      this.return_value = return_value;
      throw this;
    };

    Breaker.prototype.handle_break = function(e) {
      if (this === e) {
        return e.return_value;
      } else {
        throw e;
      }
    };

    return Breaker;

  })();

  RubyJS.Kernel = (function() {
    function Kernel() {}

    Kernel.prototype.rubyjs = function() {
      return true;
    };

    Kernel.prototype.box = function(obj, recursive, block) {
      var object_type, _v;
      if (obj == null) {
        return obj;
      }
      if (typeof obj === 'object') {
        if (obj.rubyjs != null) {
          return obj;
        }
        _v = obj.valueOf();
        if (typeof _v !== 'object') {
          obj = _v;
        } else {
          if (R.Array.isNativeArray(obj)) {
            object_type = '[object Array]';
          } else {
            object_type = nativeToString.call(obj);
          }
        }
      }
      if (typeof obj === 'number') {
        obj = RubyJS.Numeric.typecast(obj);
      } else if (typeof obj === 'string') {
        obj = new R.String(obj);
      } else if (object_type === '[object Array]') {
        obj = new R.Array(obj, recursive === true);
      } else if (object_type === '[object RegExp]') {
        obj = R.Regexp.try_convert(obj);
      }
      if (typeof recursive === 'function') {
        block = recursive;
        recursive = false;
      }
      if (typeof block === 'function') {
        obj = block.call(obj);
        if (obj === null || obj === void 0) {
          obj = null;
        } else if (obj.to_native != null) {
          obj = obj.to_native(true);
        }
      }
      return obj;
    };

    Kernel.prototype.w = function(str) {
      return new R.String(str).split(/\s+/);
    };

    Kernel.prototype.r = function(a, b, excluding) {
      if (excluding === true) {
        return R.Range["new"](a, b, true);
      } else {
        return R.Range["new"](a, b);
      }
    };

    Kernel.prototype.f = function(flt) {
      return new R.Float(flt);
    };

    Kernel.prototype.rng = Kernel.prototype.r;

    Kernel.prototype.catch_break = function(block, context) {
      var breaker, e;
      if (context == null) {
        context = this;
      }
      breaker = new R.Breaker();
      try {
        return block.call(context, breaker);
      } catch (_error) {
        e = _error;
        return breaker.handle_break(e);
      }
    };

    Kernel.prototype.$Array = function(obj, recursive) {
      var e;
      if (recursive == null) {
        recursive = false;
      }
      if (recursive === true) {
        return R.Array["new"]((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = obj.length; _i < _len; _i++) {
            e = obj[_i];
            _results.push(this.box(e));
          }
          return _results;
        }).call(this));
      } else {
        return R.Array["new"](obj);
      }
    };

    Kernel.prototype.arr_r = function(obj) {
      var e;
      return new RArray((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = obj.length; _i < _len; _i++) {
          e = obj[_i];
          _results.push(R(e));
        }
        return _results;
      })());
    };

    Kernel.prototype.$Array_r = function(obj) {
      return this.$Array(obj, true);
    };

    Kernel.prototype.$Float = function(obj) {
      var stripped;
      obj = this.box(obj);
      if (obj === null) {
        throw R.TypeError["new"]();
      }
      if (obj.to_f == null) {
        throw R.TypeError["new"]();
      }
      if (obj.is_float != null) {
        return obj;
      } else if (obj.is_string != null) {
        stripped = obj.strip();
        if (stripped.valid_float()) {
          return new R.Float(+stripped.to_native().replace(/_/g, ''));
        } else {
          throw R.ArgumentError["new"]();
        }
      } else if (obj.rubyjs != null) {
        return new R.Float(obj.to_native());
      } else {
        return new R.Float(obj);
      }
    };

    Kernel.prototype.$Integer = function(obj) {
      var stripped;
      obj = R(obj);
      if (obj == null) {
        throw R.TypeError["new"]();
      }
      if (obj.is_integer != null) {
        return obj;
      } else if (obj.is_string != null) {
        stripped = obj.strip();
        if (stripped.valid_float()) {
          return new R.Fixnum(Math.floor(+stripped.to_native().replace(/_/g, '')));
        } else {
          throw R.ArgumentError["new"]();
        }
      } else if (obj.rubyjs != null) {
        return new R.Fixnum(Math.floor(obj.to_native()));
      } else {
        return new R.Fixnum(Math.floor(obj));
      }
    };

    Kernel.prototype.$Integer = Kernel.prototype.$Integer;

    Kernel.prototype.$String = function(obj) {
      return R.String.try_convert(obj) || (function() {
        throw R.TypeError["new"]();
      })();
    };

    Kernel.prototype.$Range = function(start, end, exclusive) {
      return R.Range["new"](start, end, exclusive);
    };

    Kernel.prototype.puts = function(obj) {
      return console.log(obj.valueOf());
    };

    Kernel.prototype.rand = function(limit) {
      var r;
      r = R(Math.random());
      if (limit) {
        return r.multiply(limit).to_i();
      } else {
        return r;
      }
    };

    return Kernel;

  })();

  __enumerate = function(func, args) {
    var ary;
    ary = [];
    args.push(function() {
      if (arguments.length > 1) {
        return ary.push(nativeSlice.call(arguments, 0));
      } else {
        return ary.push(arguments[0]);
      }
    });
    func.apply(null, args);
    return ary;
  };

  __rand = RubyJS.Kernel.prototype.rand;

  RubyJS.Base = (function() {
    function Base() {}

    RubyJS.include.call(Base, R.Kernel);

    Base.prototype['$~'] = null;

    Base.prototype['$,'] = null;

    Base.prototype['$;'] = "\n";

    Base.prototype['$/'] = "\n";

    Base.prototype.inspect = function(obj) {
      if (obj === null || obj === 'undefined') {
        return 'null';
      } else if (obj.inspect != null) {
        return obj.inspect();
      } else if (R.Array.isNativeArray(obj)) {
        return "[" + obj + "]";
      } else {
        return obj;
      }
    };

    Base.prototype.pollute_global_with_kernel = function(prefix) {
      var args, name, _i, _len;
      if (prefix == null) {
        prefix = "_";
      }
      args = ['w', 'fn', 'proc', 'puts', 'truthy', 'falsey', 'inspect'];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        name = args[_i];
        root[prefix + name] = R[name];
      }
      return null;
    };

    Base.prototype.pollute_global_with_shortcuts = function(prefix) {
      var k, shortcuts, v;
      if (prefix == null) {
        prefix = "_";
      }
      shortcuts = {
        _arr: 'a',
        _num: 'n',
        _str: 's',
        _itr: 'i',
        _hsh: 'h',
        _time: 't'
      };
      for (k in shortcuts) {
        v = shortcuts[k];
        R[prefix + v] = R[k];
        root[prefix + v] = R[k];
      }
      return null;
    };

    Base.prototype.god_mode = function(prefix, overwrite) {
      var func, methods, name, new_name, overwrites, proto, _i, _len, _ref, _results;
      if (prefix == null) {
        prefix = 'rb_';
      }
      if (overwrite == null) {
        overwrite = false;
      }
      overwrites = [[Array.prototype, _arr], [Number.prototype, _num], [String.prototype, _str], [Date.prototype, _time]];
      _results = [];
      for (_i = 0, _len = overwrites.length; _i < _len; _i++) {
        _ref = overwrites[_i], proto = _ref[0], methods = _ref[1];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (name in methods) {
            func = methods[name];
            new_name = prefix + name;
            if (typeof func === 'function') {
              if (overwrite || proto[new_name] === void 0) {
                _results1.push((function(new_name, func) {
                  return proto[new_name] = callFunctionWithThis(func);
                })(new_name, func));
              } else {
                _results1.push(console.log("" + proto + "." + new_name + " exists. skipped."));
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };

    Base.prototype.i_am_feeling_evil = function() {
      this.god_mode('', true);
      return "harr harr";
    };

    Base.prototype.proc = function(key) {
      var args;
      if (arguments.length === 1) {
        return function(el) {
          var fn;
          fn = el[key];
          if (typeof fn === 'function') {
            return fn.call(el);
          } else if (fn === void 0) {
            return R(el)[key]().valueOf();
          } else {
            return fn;
          }
        };
      } else {
        args = nativeSlice.call(arguments, 1);
        return function(el) {
          var fn;
          fn = el[key];
          if (typeof fn === 'function') {
            return el[key].apply(el, args);
          } else {
            el = R(el);
            return el[key].apply(el, args).valueOf();
          }
        };
      }
    };

    Base.prototype.fn = function(func) {
      return function(el) {
        arguments[0] = el;
        return func.apply(null, arguments);
      };
    };

    Base.prototype.falsey = function(obj) {
      return obj === false || obj === null || obj === void 0;
    };

    Base.prototype.truthy = function(obj) {
      return !__falsey(obj);
    };

    Base.prototype.respond_to = function(obj, function_name) {
      return obj[function_name] !== void 0;
    };

    Base.prototype.is_equal = function(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a === 'object') {
        if (a.equals != null) {
          return a.equals(b);
        } else if (__isArr(a)) {
          return _arr.equals(a, b);
        } else if (a.valueOf != null) {
          return a.valueOf() === b.valueOf();
        } else {
          return false;
        }
      } else if (typeof b === 'object') {
        if (b.equals != null) {
          return b.equals(a);
        } else if (__isArr(b)) {
          return _arr.equals(a, b);
        } else if (b.valueOf != null) {
          return b.valueOf() === a.valueOf();
        } else {
          return false;
        }
      } else {
        return a === b;
      }
    };

    Base.prototype.is_eql = function(a, b) {
      if (typeof a === 'object') {
        return a.eql(b);
      } else if (typeof b === 'object') {
        return b.eql(a);
      } else {
        return a === b;
      }
    };

    Base.prototype.extend = function(obj, mixin) {
      var method, name;
      for (name in mixin) {
        method = mixin[name];
        obj[name] = method;
      }
      return obj;
    };

    return Base;

  })();

  _ref = RubyJS.Base.prototype;
  for (name in _ref) {
    if (!__hasProp.call(_ref, name)) continue;
    method = _ref[name];
    RubyJS[name] = method;
  }

  __falsey = R.falsey;

  __truthy = R.truthy;

  __equals = R.is_equal;

  errors = ['ArgumentError', 'RegexpError', 'TypeError', 'KeyError', 'IndexError', 'FloatDomainError', 'RangeError', 'StandardError', 'ZeroDivisionError', 'NotSupportedError', 'NotImplementedError'];

  _fn = function(error) {
    var errorClass, _ref1;
    errorClass = (function(_super) {
      __extends(_Class, _super);

      function _Class() {
        _ref1 = _Class.__super__.constructor.apply(this, arguments);
        return _ref1;
      }

      return _Class;

    })(Error);
    errorClass["new"] = function() {
      return new RubyJS[error](error);
    };
    return RubyJS[error] = this["R" + error] = errorClass;
  };
  for (_i = 0, _len = errors.length; _i < _len; _i++) {
    error = errors[_i];
    _fn(error);
  }

  _coerce = {
    "native": function(obj) {
      if (typeof obj !== 'object') {
        return obj;
      } else {
        return obj.valueOf();
      }
    },
    str: function(obj) {
      if (obj === null) {
        _err.throw_type();
      }
      if (typeof obj === 'object') {
        obj = obj.valueOf();
      }
      if (typeof obj !== 'string') {
        _err.throw_type();
      }
      return obj;
    },
    try_str: function(obj) {
      if (typeof obj === 'string') {
        return obj;
      }
      if (obj !== null) {
        obj = obj.valueOf();
      }
      if (typeof obj === 'string') {
        return obj;
      }
      return null;
    },
    num: function(obj) {
      if (obj === null) {
        _err.throw_type();
      }
      if (typeof obj === 'object') {
        obj = obj.valueOf();
      }
      if (typeof obj !== 'number') {
        _err.throw_type();
      }
      return obj;
    },
    int: function(obj) {
      if (obj === null) {
        _err.throw_type();
      }
      if (typeof obj === 'object') {
        obj = obj.valueOf();
      }
      if (typeof obj !== 'number') {
        _err.throw_type();
      }
      return Math.floor(obj);
    },
    isArray: nativeArray.isArray || function(obj) {
      return nativeToString.call(obj) === '[object Array]';
    },
    is_arr: function(obj) {
      return typeof obj === 'object' && obj !== null && _coerce.isArray(obj.valueOf());
    },
    is_str: function(obj) {
      if (typeof obj === 'string') {
        return true;
      }
      return typeof obj === 'object' && obj !== null && typeof obj.valueOf() === 'string';
    },
    is_rgx: function(obj) {
      if (obj == null) {
        return false;
      }
      return nativeToString.call(obj.valueOf()) === '[object RegExp]';
    },
    arr: function(obj) {
      if (obj === null) {
        _err.throw_type();
      }
      if (typeof obj !== 'object') {
        _err.throw_type();
      }
      obj = obj.valueOf();
      if (!_coerce.isArray(obj)) {
        _err.throw_type();
      }
      return obj;
    },
    split_args: function(args, offset) {
      var arg_len, ary, el, idx;
      arg_len = args.length;
      ary = [];
      idx = offset;
      while (idx < arg_len) {
        el = args[idx];
        if (el !== void 0) {
          ary.push(el);
        }
        idx += 1;
      }
      return ary;
    },
    call_with: function(func, thisArg, args) {
      var a;
      a = args;
      switch (args.length) {
        case 0:
          return func(thisArg);
        case 1:
          return func(thisArg, a[0]);
        case 2:
          return func(thisArg, a[0], a[1]);
        case 3:
          return func(thisArg, a[0], a[1], a[2]);
        case 4:
          return func(thisArg, a[0], a[1], a[2], a[3]);
        case 5:
          return func(thisArg, a[0], a[1], a[2], a[3], a[4]);
        case 6:
          return func(thisArg, a[0], a[1], a[2], a[3], a[4], a[5]);
        default:
          return func.apply(null, [thisArg].concat(nativeSlice.call(args, 0)));
      }
    },
    cmp: function(a, b) {
      if (typeof a !== 'object' && typeof a === typeof b) {
        if (a === b) {
          return 0;
        } else {
          if (a < b) {
            return -1;
          } else {
            return 1;
          }
        }
      } else {
        if (__isArr(a)) {
          return _arr.cmp(a, b);
        } else {
          a = R(a);
          if (a.cmp == null) {
            throw 'NoMethodError';
          }
          return a.cmp(b);
        }
      }
    },
    cmpstrict: function(a, b) {
      var cmp;
      if (typeof a === typeof b && typeof a !== 'object') {
        if (a === b) {
          return 0;
        } else {
          if (a < b) {
            return -1;
          } else {
            return 1;
          }
        }
      } else {
        a = R(a);
        if (a.cmp == null) {
          throw 'NoMethodError';
        }
        cmp = a.cmp(b);
        if (cmp === null) {
          _err.throw_argument();
        }
        return cmp;
      }
    }
  };

  R.Support.coerce = _coerce;

  __str = _coerce.str;

  __int = _coerce.int;

  __num = _coerce.num;

  __arr = _coerce.arr;

  __isArr = _coerce.is_arr;

  __isStr = _coerce.is_str;

  __isRgx = _coerce.is_rgx;

  __call = _coerce.call_with;

  __cmp = _coerce.cmp;

  __cmpstrict = _coerce.cmpstrict;

  __try_str = _coerce.try_str;

  _err = {
    throw_argument: function(msg) {
      throw RArgumentError["new"](msg);
    },
    throw_type: function(msg) {
      throw RTypeError["new"](msg);
    },
    throw_index: function(msg) {
      throw RIndexError["new"](msg);
    },
    throw_not_implemented: function(msg) {
      throw RNotImplementedError["new"](msg);
    },
    throw_key: function(msg) {
      throw RKeyError["new"](msg);
    }
  };

  R.Support.err = _err;

  NumericMethods = (function() {
    function NumericMethods() {}

    NumericMethods.prototype.cmp = function(num, other) {
      if (num === other) {
        return 0;
      } else {
        return null;
      }
    };

    NumericMethods.prototype.abs = function(num) {
      if (num < 0) {
        return -num;
      } else {
        return num;
      }
    };

    NumericMethods.prototype.abs2 = function(num) {
      if (typeof this.nan === "function" ? this.nan(num) : void 0) {
        return num;
      }
      return Math.pow(num, 2);
    };

    NumericMethods.prototype.ceil = function(num) {
      return Math.ceil(num);
    };

    NumericMethods.prototype.divmod = function(num, other) {
      var modulus, quotient;
      quotient = Math.floor(num / other);
      modulus = num % other;
      return [quotient, modulus];
    };

    NumericMethods.prototype.downto = function(num, stop, block) {
      var idx;
      if ((block != null ? block.call : void 0) == null) {
        return __enumerate(_num.downto, [num, stop]);
      }
      stop = Math.ceil(stop);
      idx = num;
      while (idx >= stop) {
        block(idx);
        idx -= 1;
      }
      return num;
    };

    NumericMethods.prototype.eql = function(num, other) {
      return num === other;
    };

    NumericMethods.prototype.floor = function(num) {
      return Math.floor(num);
    };

    NumericMethods.prototype.nonzero = function(num) {
      if (num === 0) {
        return null;
      } else {
        return num;
      }
    };

    NumericMethods.prototype.step = function(num, limit, step, block) {
      var d, float_mode, i, n;
      if (step == null) {
        step = 1;
      }
      if (!(((block != null ? block.call : void 0) != null) || ((step != null ? step.call : void 0) != null))) {
        return __enumerate(_num.step, [num, limit, step]);
      }
      if ((block != null ? block.call : void 0) == null) {
        block = step;
        step = 1;
      }
      if (step === 0) {
        _err.throw_argument();
      }
      float_mode = num % 1 === 0 || limit % 1 === 0 || step % 1 === 0;
      if (float_mode) {
        n = (limit - num) / step;
        i = 0;
        if (step > 0) {
          while (i <= n) {
            d = i * step + num;
            if (limit < d) {
              d = limit;
            }
            block(d);
            i += 1;
          }
        } else {
          while (i <= n) {
            d = i * step + num;
            if (limit > d) {
              d = limit;
            }
            block(d);
            i += 1;
          }
        }
      } else {
        if (step > 0) {
          while (!(num > limit)) {
            block(num);
            num += step;
          }
        } else {
          while (!(num < limit)) {
            block(num);
            num += step;
          }
        }
      }
      return this;
    };

    NumericMethods.prototype.upto = function(num, stop, block) {
      var idx;
      if ((block != null ? block.call : void 0) == null) {
        return __enumerate(_num.upto, [num, stop]);
      }
      stop = Math.floor(stop);
      idx = num;
      while (idx <= stop) {
        block(idx);
        idx += 1;
      }
      return num;
    };

    NumericMethods.prototype.zero = function(num) {
      return num === 0;
    };

    NumericMethods.prototype.even = function(num) {
      return num % 2 === 0;
    };

    NumericMethods.prototype.gcd = function(num, other) {
      var t;
      t = null;
      other = __int(other);
      while (other !== 0) {
        t = other;
        other = num % other;
        num = t;
      }
      if (num < 0) {
        return -num;
      } else {
        return num;
      }
    };

    NumericMethods.prototype.gcdlcm = function(num, other) {
      other = __int(other);
      return [_num.gcd(num, other), _num.lcm(num, other)];
    };

    NumericMethods.prototype.lcm = function(num, other) {
      var lcm;
      other = __int(other);
      lcm = num * other / _num.gcd(num, other);
      return _num.numerator(lcm);
    };

    NumericMethods.prototype.numerator = function(num) {
      if (num < 0) {
        return -num;
      } else {
        return num;
      }
    };

    NumericMethods.prototype.odd = function(num) {
      return num % 2 === 1;
    };

    NumericMethods.prototype.ord = function() {
      return this;
    };

    NumericMethods.prototype.next = function(num) {
      return num + 1;
    };

    NumericMethods.prototype.pred = function(num) {
      return num - 1;
    };

    NumericMethods.prototype.round = function(num, n) {
      var multiplier;
      if (n === void 0) {
        return num;
      }
      multiplier = Math.pow(10, __int(n));
      return Math.round(num * multiplier) / multiplier;
    };

    NumericMethods.prototype.times = function(num, block) {
      var idx;
      if ((block != null ? block.call : void 0) == null) {
        return __enumerate(_num.times, [num]);
      }
      if (num > 0) {
        idx = 0;
        while (idx < num) {
          block(idx);
          idx = idx + 1;
        }
        return num;
      } else {
        return num;
      }
    };

    NumericMethods.prototype.magnitude = NumericMethods.prototype.abs;

    NumericMethods.prototype.succ = NumericMethods.prototype.next;

    return NumericMethods;

  })();

  _num = R._num = new NumericMethods();

  EnumerableMethods = (function() {
    function EnumerableMethods() {}

    EnumerableMethods.prototype.catch_break = R.Kernel.prototype.catch_break;

    EnumerableMethods.prototype.each = function(coll, block) {
      var k, v;
      if (coll.each != null) {
        coll.each(block);
      } else if (__isArr(coll)) {
        _arr.each(coll, block);
      } else {
        for (k in coll) {
          if (!__hasProp.call(coll, k)) continue;
          v = coll[k];
          block(k, v);
        }
      }
      return coll;
    };

    EnumerableMethods.prototype.all = function(coll, block) {
      return _itr.catch_break(function(breaker) {
        var callback;
        callback = __blockify(block, coll);
        _itr.each(coll, function() {
          var result;
          result = callback.invoke(arguments);
          if (__falsey(result)) {
            return breaker["break"](false);
          }
        });
        return true;
      });
    };

    EnumerableMethods.prototype.any = function(coll, block) {
      return _itr.catch_break(function(breaker) {
        var callback;
        callback = __blockify(block, coll);
        _itr.each(coll, function() {
          var result;
          result = callback.invoke(arguments);
          if (!__falsey(result)) {
            return breaker["break"](true);
          }
        });
        return false;
      });
    };

    EnumerableMethods.prototype.collect_concat = function(coll, block) {
      var ary, callback;
      if (block == null) {
        block = null;
      }
      callback = __blockify(block, this);
      ary = [];
      _itr.each(coll, function() {
        return ary.push(callback.invoke(arguments));
      });
      return _arr.flatten(ary, 1);
    };

    EnumerableMethods.prototype.flat_map = EnumerableMethods.collect_concat;

    EnumerableMethods.prototype.count = function(coll, block) {
      var callback, countable, counter;
      counter = 0;
      if (block === void 0) {
        _itr.each(coll, function() {
          return counter += 1;
        });
      } else if (block === null) {
        _itr.each(coll, function(el) {
          if (el === null) {
            return counter += 1;
          }
        });
      } else if (block.call != null) {
        callback = __blockify(block, coll);
        _itr.each(coll, function() {
          var result;
          result = callback.invoke(arguments);
          if (!__falsey(result)) {
            return counter += 1;
          }
        });
      } else {
        countable = block;
        _itr.each(coll, function(el) {
          if (__equals(countable, el)) {
            return counter += 1;
          }
        });
      }
      return counter;
    };

    EnumerableMethods.prototype.cycle = function(coll, n, block) {
      var cache, callback, i, many, _results, _results1;
      if (!block) {
        if (n && (n.call != null)) {
          block = n;
          n = null;
        }
      }
      if (!(n === null || n === void 0)) {
        many = __int(n);
        if (many <= 0) {
          return null;
        }
      } else {
        many = null;
      }
      if (!block) {
        return __enumerate(_itr.cycle, [n]);
      }
      callback = __blockify(block, coll);
      cache = [];
      _itr.each(coll, function() {
        cache.push(callback.args(arguments));
        return callback.invoke(arguments);
      });
      if (cache.length === 0) {
        return null;
      }
      if (many > 0) {
        i = 0;
        many -= 1;
        _results = [];
        while (many > i) {
          _results.push(_arr.each(cache, function() {
            callback.invoke(arguments);
            return i += 1;
          }));
        }
        return _results;
      } else {
        _results1 = [];
        while (true) {
          _results1.push(_arr.each(cache, function() {
            return callback.invoke(arguments);
          }));
        }
        return _results1;
      }
    };

    EnumerableMethods.prototype.drop = function(coll, n) {
      var ary;
      ary = [];
      _itr.each_with_index(coll, function(el, idx) {
        if (n <= idx) {
          return ary.push(el);
        }
      });
      return ary;
    };

    EnumerableMethods.prototype.drop_while = function(coll, block) {
      var ary, callback, dropping;
      callback = __blockify(block, coll);
      ary = [];
      dropping = true;
      _itr.each(coll, function() {
        if (!(dropping && callback.invoke(arguments))) {
          dropping = false;
          return ary.push(callback.args(arguments));
        }
      });
      return ary;
    };

    EnumerableMethods.prototype.each_cons = function(coll, n, block) {
      var ary, callback, len;
      callback = __blockify(block, coll);
      len = block.length;
      ary = [];
      _itr.each(coll, function() {
        ary.push(BlockMulti.prototype.args(arguments));
        if (ary.length > n) {
          ary.shift();
        }
        if (ary.length === n) {
          if (len > 1) {
            return block.apply(coll, ary.slice(0));
          } else {
            return block.call(coll, ary.slice(0));
          }
        }
      });
      return null;
    };

    EnumerableMethods.prototype.each_entry = function(coll, block) {
      var callback, len;
      callback = new BlockMulti(block, coll);
      len = block.length;
      _itr.each(coll, function() {
        var args;
        args = callback.args(arguments);
        if (len > 1 && __isArr(args)) {
          return block.apply(coll, args);
        } else {
          return block.call(coll, args);
        }
      });
      return coll;
    };

    EnumerableMethods.prototype.each_slice = function(coll, n, block) {
      var args, ary, callback, len;
      callback = __blockify(block, coll);
      len = block.length;
      ary = [];
      _itr.each(coll, function() {
        var args;
        ary.push(BlockMulti.prototype.args(arguments));
        if (ary.length === n) {
          args = ary.slice(0);
          if (len > 1) {
            block.apply(coll, args);
          } else {
            block.call(coll, args);
          }
          return ary = [];
        }
      });
      if (ary.length !== 0) {
        args = ary.slice(0);
        if (len > 1) {
          block.apply(coll, args);
        } else {
          block.call(coll, args);
        }
      }
      return null;
    };

    EnumerableMethods.prototype.each_with_index = function(coll, block) {
      var callback, idx;
      if ((block != null ? block.call : void 0) == null) {
        return __enumerate(_itr.each_with_index, [coll]);
      }
      callback = __blockify(block, coll);
      idx = 0;
      _itr.each(coll, function() {
        var val;
        val = callback.invokeSplat(callback.args(arguments), idx);
        idx += 1;
        return val;
      });
      return coll;
    };

    EnumerableMethods.prototype.each_with_object = function(coll, obj, block) {
      var callback;
      if ((block != null ? block.call : void 0) == null) {
        return __enumerate(_itr.each_with_object, [coll, obj]);
      }
      callback = __blockify(block, coll);
      _itr.each(coll, function() {
        var args;
        args = BlockMulti.prototype.args(arguments);
        return callback.invokeSplat(args, obj);
      });
      return obj;
    };

    EnumerableMethods.prototype.find = function(coll, ifnone, block) {
      var callback;
      if (block == null) {
        block = null;
      }
      if (block === null) {
        block = ifnone;
        ifnone = null;
      }
      callback = __blockify(block, this);
      return _itr.catch_break(function(breaker) {
        _itr.each(coll, function() {
          if (!__falsey(callback.invoke(arguments))) {
            return breaker["break"](callback.args(arguments));
          }
        });
        return typeof ifnone === "function" ? ifnone() : void 0;
      });
    };

    EnumerableMethods.prototype.find_all = function(coll, block) {
      var ary, callback;
      ary = [];
      callback = __blockify(block, coll);
      _itr.each(coll, function() {
        if (!__falsey(callback.invoke(arguments))) {
          return ary.push(callback.args(arguments));
        }
      });
      return ary;
    };

    EnumerableMethods.prototype.find_index = function(coll, value) {
      var block;
      if (value.call != null) {
        block = value;
      } else {
        block = function(el) {
          return __equals(value, el);
        };
      }
      return _itr.catch_break(function(breaker) {
        var callback, idx;
        idx = 0;
        callback = __blockify(block, coll);
        _itr.each(coll, function() {
          if (callback.invoke(arguments)) {
            breaker["break"](idx);
          }
          return idx += 1;
        });
        return null;
      });
    };

    EnumerableMethods.prototype.first = function(coll, n) {
      if (n == null) {
        n = null;
      }
      if (n !== null) {
        if (n < 0) {
          _err.throw_argument();
        }
        return _itr.take(coll, n);
      } else {
        return _itr.take(coll, 1)[0];
      }
    };

    EnumerableMethods.prototype.include = function(coll, other) {
      return _itr.catch_break(function(breaker) {
        _itr.each(coll, function(el) {
          if (__equals(other, el)) {
            return breaker["break"](true);
          }
        });
        return false;
      });
    };

    EnumerableMethods.prototype.__inject_args__ = function(initial, sym, block) {
      var _ref1;
      if ((sym != null ? sym.call : void 0) != null) {
        block = sym;
      } else if (sym) {
        block = function(memo, el) {
          return memo[sym](el);
        };
      } else if (((_ref1 = R(initial)) != null ? _ref1.is_string : void 0) != null) {
        block = function(memo, el) {
          return memo["" + initial](el);
        };
        initial = void 0;
      } else if (initial.call != null) {
        block = initial;
        initial = void 0;
      }
      return [initial, sym, block];
    };

    EnumerableMethods.prototype.inject = function(coll, init, sym, block) {
      var callback, _ref1;
      _ref1 = _itr.__inject_args__(init, sym, block), init = _ref1[0], sym = _ref1[1], block = _ref1[2];
      callback = __blockify(block, coll);
      _itr.each(coll, function() {
        var args;
        if (init === void 0) {
          return init = callback.args(arguments);
        } else {
          args = BlockMulti.prototype.args(arguments);
          return init = callback.invokeSplat(init, args);
        }
      });
      return init;
    };

    EnumerableMethods.prototype.grep = function(coll, pattern, block) {
      var ary, callback;
      ary = [];
      pattern = R(pattern);
      callback = __blockify(block, coll);
      if (block) {
        _itr.each(coll, function(el) {
          if (pattern['==='](el)) {
            return ary.push(callback.invoke(arguments));
          }
        });
      } else {
        _itr.each(coll, function(el) {
          if (pattern['==='](el)) {
            return ary.push(el);
          }
        });
      }
      return ary;
    };

    EnumerableMethods.prototype.group_by = function(coll, block) {
      var callback, h;
      callback = __blockify(block, coll);
      h = {};
      _itr.each(coll, function() {
        var args, key;
        args = callback.args(arguments);
        key = callback.invoke(arguments);
        h[key] || (h[key] = []);
        return h[key].push(args);
      });
      return h;
    };

    EnumerableMethods.prototype.map = function(coll, block) {
      var arr, callback;
      callback = __blockify(block, coll);
      arr = [];
      _itr.each(coll, function() {
        return arr.push(callback.invoke(arguments));
      });
      return arr;
    };

    EnumerableMethods.prototype.max = function(coll, block) {
      var max;
      max = void 0;
      block || (block = __cmp);
      _itr.each(coll, function(item) {
        var comp;
        if (max === void 0) {
          return max = item;
        } else {
          comp = block(item, max);
          if (comp === null) {
            _err.throw_argument();
          }
          if (comp > 0) {
            return max = item;
          }
        }
      });
      return max || null;
    };

    EnumerableMethods.prototype.max_by = function(coll, block) {
      var max;
      max = void 0;
      _itr.each(coll, function(item) {
        var cmp;
        if (max === void 0) {
          return max = item;
        } else {
          cmp = __cmpstrict(block(item), block(max));
          if (cmp > 0) {
            return max = item;
          }
        }
      });
      return max || null;
    };

    EnumerableMethods.prototype.min = function(coll, block) {
      var min;
      min = void 0;
      block || (block = __cmp);
      _itr.each(coll, function(item) {
        var comp;
        if (min === void 0) {
          return min = item;
        } else {
          comp = block.call(this, item, min);
          if (comp === null) {
            _err.throw_argument();
          }
          if (comp < 0) {
            return min = item;
          }
        }
      });
      return min || null;
    };

    EnumerableMethods.prototype.min_by = function(coll, block) {
      var min;
      min = void 0;
      _itr.each(coll, function(item) {
        var cmp;
        if (min === void 0) {
          return min = item;
        } else {
          cmp = __cmpstrict(block(item), block(min));
          if (cmp < 0) {
            return min = item;
          }
        }
      });
      return min || null;
    };

    EnumerableMethods.prototype.minmax = function(coll, block) {
      return [_itr.min(coll, block), _itr.max(coll, block)];
    };

    EnumerableMethods.prototype.minmax_by = function(coll, block) {
      return [_itr.min_by(coll, block), _itr.max_by(coll, block)];
    };

    EnumerableMethods.prototype.none = function(coll, block) {
      return _itr.catch_break(function(breaker) {
        var callback;
        callback = __blockify(block, coll);
        _itr.each(coll, function(args) {
          var result;
          result = callback.invoke(arguments);
          if (!__falsey(result)) {
            return breaker["break"](false);
          }
        });
        return true;
      });
    };

    EnumerableMethods.prototype.one = function(coll, block) {
      var counter;
      counter = 0;
      return _itr.catch_break(function(breaker) {
        var callback;
        callback = __blockify(block, coll);
        _itr.each(coll, function(args) {
          var result;
          result = callback.invoke(arguments);
          if (!__falsey(result)) {
            counter += 1;
          }
          if (counter > 1) {
            return breaker["break"](false);
          }
        });
        return counter === 1;
      });
    };

    EnumerableMethods.prototype.partition = function(coll, block) {
      var callback, left, right;
      left = [];
      right = [];
      callback = __blockify(block, coll);
      _itr.each(coll, function() {
        var args;
        args = BlockMulti.prototype.args(arguments);
        if (callback.invokeSplat(args)) {
          return left.push(args);
        } else {
          return right.push(args);
        }
      });
      return [left, right];
    };

    EnumerableMethods.prototype.reject = function(coll, block) {
      var ary, callback;
      callback = __blockify(block, coll);
      ary = [];
      _itr.each(coll, function() {
        if (__falsey(callback.invoke(arguments))) {
          return ary.push(callback.args(arguments));
        }
      });
      return ary;
    };

    EnumerableMethods.prototype.reverse_each = function(coll, block) {
      _arr.reverse_each(_itr.to_a(coll), block);
      return coll;
    };

    EnumerableMethods.prototype.slice_before = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    };

    EnumerableMethods.prototype.sort = function(coll, block) {
      block || (block = __cmpstrict);
      if (coll.to_native != null) {
        coll = coll.to_native();
      }
      return nativeSort.call(coll, block);
    };

    EnumerableMethods.prototype.sort_by = function(coll, block) {
      var ary, callback;
      callback = __blockify(block, coll);
      ary = [];
      _itr.each(coll, function(value) {
        return ary.push(new SortedElement(value, callback.invoke(arguments)));
      });
      ary = _arr.sort(ary, __cmpstrict);
      return _arr.map(ary, function(se) {
        return se.value;
      });
    };

    EnumerableMethods.prototype.take = function(coll, n) {
      var ary;
      if (n < 0) {
        _err.throw_argument();
      }
      ary = [];
      _itr.catch_break(function(breaker) {
        return _itr.each(coll, function() {
          if (ary.length === n) {
            breaker["break"]();
          }
          return ary.push(BlockMulti.prototype.args(arguments));
        });
      });
      return ary;
    };

    EnumerableMethods.prototype.take_while = function(coll, block) {
      var ary;
      ary = [];
      _itr.catch_break(function(breaker) {
        return _itr.each(coll, function() {
          if (__falsey(block.apply(coll, arguments))) {
            breaker["break"]();
          }
          return ary.push(BlockMulti.prototype.args(arguments));
        });
      });
      return ary;
    };

    EnumerableMethods.prototype.to_a = function(coll) {
      var ary;
      ary = [];
      _itr.each(coll, function() {
        var args;
        args = arguments.length > 1 ? nativeSlice.call(arguments, 0) : arguments[0];
        ary.push(args);
        return null;
      });
      return ary;
    };

    EnumerableMethods.prototype.zip = function(coll, others) {};

    EnumerableMethods.prototype.detect = EnumerableMethods.prototype.find;

    EnumerableMethods.prototype.select = EnumerableMethods.prototype.find_all;

    EnumerableMethods.prototype.collectConcat = EnumerableMethods.prototype.collect_concat;

    EnumerableMethods.prototype.dropWhile = EnumerableMethods.prototype.drop_while;

    EnumerableMethods.prototype.eachCons = EnumerableMethods.prototype.each_cons;

    EnumerableMethods.prototype.eachEntry = EnumerableMethods.prototype.each_entry;

    EnumerableMethods.prototype.eachSlice = EnumerableMethods.prototype.each_slice;

    EnumerableMethods.prototype.eachWithIndex = EnumerableMethods.prototype.each_with_index;

    EnumerableMethods.prototype.eachWithObject = EnumerableMethods.prototype.each_with_object;

    EnumerableMethods.prototype.findAll = EnumerableMethods.prototype.find_all;

    EnumerableMethods.prototype.findIndex = EnumerableMethods.prototype.find_index;

    EnumerableMethods.prototype.flatMap = EnumerableMethods.prototype.flat_map;

    EnumerableMethods.prototype.groupBy = EnumerableMethods.prototype.group_by;

    EnumerableMethods.prototype.maxBy = EnumerableMethods.prototype.max_by;

    EnumerableMethods.prototype.minBy = EnumerableMethods.prototype.min_by;

    EnumerableMethods.prototype.minmaxBy = EnumerableMethods.prototype.minmax_by;

    EnumerableMethods.prototype.reverseEach = EnumerableMethods.prototype.reverse_each;

    EnumerableMethods.prototype.sliceBefore = EnumerableMethods.prototype.slice_before;

    EnumerableMethods.prototype.sortBy = EnumerableMethods.prototype.sort_by;

    EnumerableMethods.prototype.takeWhile = EnumerableMethods.prototype.take_while;

    EnumerableMethods.prototype.toA = EnumerableMethods.prototype.to_a;

    EnumerableMethods.prototype.collect = EnumerableMethods.prototype.map;

    EnumerableMethods.prototype.member = EnumerableMethods.prototype.include;

    EnumerableMethods.prototype.reduce = EnumerableMethods.prototype.inject;

    EnumerableMethods.prototype.entries = EnumerableMethods.prototype.to_a;

    return EnumerableMethods;

  })();

  SortedElement = (function() {
    function SortedElement(value, sort_by) {
      this.value = value;
      this.sort_by = sort_by;
    }

    SortedElement.prototype.cmp = function(other) {
      var _ref1;
      return (_ref1 = this.sort_by) != null ? _ref1.cmp(other.sort_by) : void 0;
    };

    return SortedElement;

  })();

  _itr = R._itr = new EnumerableMethods();

  ArrayMethods = (function(_super) {
    __extends(ArrayMethods, _super);

    function ArrayMethods() {
      _ref1 = ArrayMethods.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    ArrayMethods.prototype.equals = function(arr, other) {
      var i, total;
      if (arr === other) {
        return true;
      }
      if (other == null) {
        return false;
      }
      if (__isArr(other)) {
        other = __arr(other);
      } else {
        return false;
      }
      if (arr.length !== other.length) {
        return false;
      }
      i = 0;
      total = i + arr.length;
      while (i < total) {
        if (!__equals(arr[i], other[i])) {
          return false;
        }
        i += 1;
      }
      return true;
    };

    ArrayMethods.prototype.append = function(arr, obj) {
      arr.push(obj);
      return arr;
    };

    ArrayMethods.prototype.intersection = function(arr, other) {
      var out;
      other = __arr(other);
      out = [];
      _arr.each(arr, function(el) {
        if (_arr.include(other, el)) {
          return out.push(el);
        }
      });
      return _arr.uniq(out);
    };

    ArrayMethods.prototype.cmp = function(arr, other) {
      var diff, e, i, len, other_total, total;
      if (other == null) {
        return null;
      }
      try {
        other = __arr(other);
      } catch (_error) {
        e = _error;
        return null;
      }
      if (_arr.equals(arr, other)) {
        return 0;
      }
      len = arr.length;
      other_total = other.length;
      i = 0;
      total = other_total < len ? other_total : len;
      while (total > i) {
        diff = __cmp(arr[i], other[i]);
        if (diff !== 0) {
          return diff;
        }
        i += 1;
      }
      return __cmp(len, other_total);
    };

    ArrayMethods.prototype.at = function(arr, index) {
      if (index < 0) {
        return arr[arr.length + index];
      } else {
        return arr[index];
      }
    };

    ArrayMethods.prototype.combination = function(arr, num, block) {
      var chosen, done, i, len, lev, stack;
      if ((block != null ? block.call : void 0) == null) {
        return __enumerate(_arr.combination, [arr, num]);
      }
      num = __int(num);
      len = arr.length;
      if (num === 0) {
        block([]);
      } else if (num === 1) {
        _arr.each(arr, function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return block.call(arr, args);
        });
      } else if (num === len) {
        block(arr.slice(0));
      } else if (num >= 0 && num < len) {
        num = num;
        stack = (function() {
          var _j, _ref2, _results;
          _results = [];
          for (i = _j = 0, _ref2 = num + 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
            _results.push(0);
          }
          return _results;
        })();
        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;
        while (!done) {
          chosen[lev] = arr[stack[lev + 1]];
          while (lev < num - 1) {
            lev += 1;
            stack[lev + 1] = stack[lev] + 1;
            chosen[lev] = arr[stack[lev + 1]];
          }
          block.call(arr, chosen.slice(0));
          lev += 1;
          done = lev === 0;
          stack[lev] += 1;
          lev = lev - 1;
          while (stack[lev + 1] + num === len + lev + 1) {
            done = lev === 0;
            stack[lev] += 1;
            lev = lev - 1;
          }
        }
      }
      return arr;
    };

    ArrayMethods.prototype.compact = function(arr) {
      var ary, el, _j, _len1;
      ary = [];
      for (_j = 0, _len1 = arr.length; _j < _len1; _j++) {
        el = arr[_j];
        if (el != null) {
          ary.push(el);
        }
      }
      return ary;
    };

    ArrayMethods.prototype["delete"] = function(arr, obj, block) {
      var deleted, i, len, _j, _len1, _ref2;
      deleted = [];
      i = 0;
      len = arr.length;
      while (i < len) {
        if (__equals(obj, arr[i])) {
          deleted.push(i);
        }
        i += 1;
      }
      if (deleted.length > 0) {
        _ref2 = deleted.reverse();
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          i = _ref2[_j];
          arr.splice(i, 1);
        }
        return obj;
      }
      if (block) {
        return block();
      } else {
        return null;
      }
    };

    ArrayMethods.prototype.delete_at = function(arr, idx) {
      if (idx < 0) {
        idx = idx + arr.length;
      }
      if (idx < 0 || idx >= arr.length) {
        return null;
      }
      return arr.splice(idx, 1)[0];
    };

    ArrayMethods.prototype.first = function(arr, n) {
      if (n != null) {
        if (n < 0) {
          _err.throw_argument();
        }
        return arr.slice(0, n);
      } else {
        return arr[0];
      }
    };

    ArrayMethods.prototype.flatten = function(arr, recursion) {
      var ary, el, idx, len;
      if (recursion == null) {
        recursion = -1;
      }
      arr = __arr(arr);
      ary = [];
      len = arr.length;
      idx = -1;
      while (++idx < len) {
        el = arr[idx];
        if (recursion !== 0 && __isArr(el)) {
          nativePush.apply(ary, _arr.flatten(el, recursion - 1));
        } else {
          ary.push(el);
        }
      }
      return ary;
    };

    ArrayMethods.prototype.each = function(arr, block) {
      var idx, len;
      if (block == null) {
        return arr;
      }
      block = Block.splat_arguments(block);
      idx = -1;
      len = arr.length;
      while (++idx < arr.length) {
        block(arr[idx]);
      }
      return arr;
    };

    ArrayMethods.prototype.each_with_context = function(arr, thisArg, block) {
      var idx, len;
      if (block == null) {
        return __enumerate(_arr.each_with_context, [arr, thisArg]);
      }
      block = Block.splat_arguments(block);
      idx = -1;
      len = arr.length;
      while (++idx < arr.length) {
        block.call(thisArg, arr[idx]);
      }
      return arr;
    };

    ArrayMethods.prototype.each_index = function(arr, block) {
      var idx, len;
      if (block == null) {
        return __enumerate(_arr.each_index, [arr]);
      }
      idx = -1;
      len = arr.length;
      while (++idx < len) {
        block(idx);
      }
      return this;
    };

    ArrayMethods.prototype.get = function(arr, b) {
      return _arr.slice(arr, b);
    };

    ArrayMethods.prototype.empty = function(arr) {
      return arr.length === 0;
    };

    ArrayMethods.prototype.fetch = function(arr, idx, default_or_block) {
      var len, orig;
      idx = __int(idx);
      len = arr.length;
      orig = idx;
      if (idx < 0) {
        idx = idx + len;
      }
      if (idx < 0 || idx >= len) {
        if ((default_or_block != null ? default_or_block.call : void 0) != null) {
          return default_or_block(orig);
        }
        if (default_or_block !== void 0) {
          return default_or_block;
        }
        _err.throw_index();
      }
      return arr[idx];
    };

    ArrayMethods.prototype.fill = function() {
      var args, arr, block, e, fill, i, left, obj, one, right, size, total, two, v;
      arr = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (args.length === 0) {
        _err.throw_argument();
      }
      block = __extract_block(args);
      if (block) {
        if (args.length >= 3) {
          _err.throw_argument();
        }
        one = args[0];
        two = args[1];
      } else {
        if (args.length > 3) {
          _err.throw_argument();
        }
        obj = args[0];
        one = args[1];
        two = args[2];
      }
      size = arr.length;
      if ((one != null ? one.is_range : void 0) != null) {
        _err.throw_not_implemented();
      } else if (one !== void 0 && one !== null) {
        left = __int(one);
        if (left < 0) {
          left = left + size;
        }
        if (left < 0) {
          left = 0;
        }
        if (two !== void 0 && two !== null) {
          try {
            right = __int(two);
          } catch (_error) {
            e = _error;
            _err.throw_argument("second argument must be a Fixnum");
          }
          if (right === 0) {
            return arr;
          }
          right = right + left;
        } else {
          right = size;
        }
      } else {
        left = 0;
        right = size;
      }
      total = right;
      if (right > size) {
        fill = _arr.__native_array_with__(right - size, null);
        arr.push.apply(arr, fill);
        total = right;
      }
      i = left;
      if (block) {
        while (total > i) {
          v = block(i);
          arr[i] = v === void 0 ? null : v;
          i += 1;
        }
      } else {
        while (total > i) {
          arr[i] = obj;
          i += 1;
        }
      }
      return arr;
    };

    ArrayMethods.prototype.insert = function(arr, idx) {
      var after, el, i, items, len, _j, _k, _l, _len1, _len2;
      if (idx === void 0) {
        _err.throw_argument();
      }
      if (arguments.length === 2) {
        return arr;
      }
      items = _coerce.split_args(arguments, 2);
      len = arr.length;
      if (idx < 0) {
        idx = idx + len + 1;
      }
      if (idx < 0) {
        _err.throw_index();
      }
      after = arr.slice(idx);
      if (idx > len) {
        for (i = _j = len; len <= idx ? _j < idx : _j > idx; i = len <= idx ? ++_j : --_j) {
          arr[i] = null;
        }
      }
      len = 0;
      for (i = _k = 0, _len1 = items.length; _k < _len1; i = ++_k) {
        el = items[i];
        if (el !== void 0) {
          arr[idx + i] = el;
          len += 1;
        }
      }
      for (i = _l = 0, _len2 = after.length; _l < _len2; i = ++_l) {
        el = after[i];
        arr[idx + len + i] = el;
      }
      return arr;
    };

    ArrayMethods.prototype.join = function(arr, separator) {
      if (arr.length === 0) {
        return '';
      }
      if (separator === void 0) {
        separator = R['$,'];
      }
      if (separator === null) {
        separator = '';
      }
      return nativeJoin.call(_arr.flatten(arr), separator);
    };

    ArrayMethods.prototype.keep_if = function(arr, block) {
      var ary, el, idx, len;
      if (block == null) {
        return __enumerate(_arr.keep_if, [arr]);
      }
      block = Block.splat_arguments(block);
      ary = [];
      idx = -1;
      len = arr.length;
      while (++idx < len) {
        el = arr[idx];
        if (!__falsey(block(el))) {
          ary.push(el);
        }
      }
      return ary;
    };

    ArrayMethods.prototype.last = function(arr, n) {
      var len;
      len = arr.length;
      if (n === void 0) {
        return arr[len - 1];
      }
      if (len === 0 || n === 0) {
        return [];
      }
      if (n < 0) {
        _err.throw_argument("count must be positive");
      }
      if (n > len) {
        n = len;
      }
      return arr.slice(-n);
    };

    ArrayMethods.prototype.minus = function(arr, other) {
      var ary, el, idx, len;
      other = __arr(other);
      ary = [];
      idx = -1;
      len = arr.length;
      while (++idx < len) {
        el = arr[idx];
        if (!_arr.include(other, el)) {
          ary.push(el);
        }
      }
      return ary;
    };

    ArrayMethods.prototype.multiply = function(arr, multiplier) {
      var ary, idx, total;
      if (multiplier === null) {
        _err.throw_type();
      }
      if (__isStr(multiplier)) {
        return _arr.join(arr, __str(multiplier));
      } else {
        multiplier = __int(multiplier);
        if (multiplier < 0) {
          _err.throw_argument("count cannot be negative");
        }
        total = arr.length;
        if (total === 0) {
          return [];
        } else if (total === 1) {
          return arr.slice(0);
        }
        ary = [];
        idx = -1;
        while (++idx < multiplier) {
          ary = ary.concat(arr);
        }
        return ary;
      }
    };

    ArrayMethods.prototype.pop = function(arr, many) {
      var ary, len;
      if (many === void 0) {
        return arr.pop();
      } else {
        many = __int(many);
        if (many < 0) {
          _err.throw_argument("negative array size");
        }
        ary = [];
        len = arr.length;
        if (many > len) {
          many = len;
        }
        while (many--) {
          ary[many] = arr.pop();
        }
        return ary;
      }
    };

    ArrayMethods.prototype.product = function() {
      var a, args, arr, block, block_result, outer, result, v, _j, _len1;
      arr = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      result = [];
      block = __extract_block(args);
      args = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
          a = args[_j];
          _results.push(__arr(a));
        }
        return _results;
      })();
      args = args.reverse();
      args.push(arr);
      outer = _arr.inject(args, result.push, function(trigger, values) {
        return function(partial) {
          var val, _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
            val = values[_j];
            _results.push(trigger.call(result, partial.concat(val)));
          }
          return _results;
        };
      });
      outer([]);
      if (block) {
        block_result = arr;
        for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
          v = result[_j];
          block_result.push(block(v));
        }
        return block_result;
      } else {
        return result;
      }
    };

    ArrayMethods.prototype.push = function() {
      var arr, elements;
      arr = arguments[0], elements = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      arr.push.apply(arr, elements);
      return arr;
    };

    ArrayMethods.prototype.rassoc = function(arr, obj) {
      var e, el, elem, idx, len;
      len = arr.length;
      idx = -1;
      while (++idx < len) {
        elem = arr[idx];
        try {
          el = __arr(elem);
          if (__equals(el[1], obj)) {
            return elem;
          }
        } catch (_error) {
          e = _error;
          null;
        }
      }
      return null;
    };

    ArrayMethods.prototype.reverse_each = function(arr, block) {
      var idx;
      if (block == null) {
        return __enumerate(_arr.reverse_each, [arr]);
      }
      block = Block.splat_arguments(block);
      idx = arr.length;
      while (idx--) {
        block(arr[idx]);
      }
      return arr;
    };

    ArrayMethods.prototype.rindex = function(arr, other) {
      var block, el, len, ridx;
      if (other === void 0) {
        return __enumerate(_arr.rindex, [arr, other]);
      }
      len = arr.length;
      ridx = arr.length;
      if (other.call != null) {
        block = Block.splat_arguments(other);
        while (ridx--) {
          el = arr[ridx];
          if (!__falsey(block(el))) {
            return ridx;
          }
        }
      } else {
        while (ridx--) {
          el = arr[ridx];
          if (__equals(el, other)) {
            return ridx;
          }
        }
      }
      return null;
    };

    ArrayMethods.prototype.rotate = function(arr, cnt) {
      var idx, len, sliced;
      if (cnt === void 0) {
        cnt = 1;
      } else {
        cnt = __int(cnt);
      }
      len = arr.length;
      if (len === 1) {
        return arr;
      }
      if (len === 0) {
        return [];
      }
      idx = cnt % len;
      sliced = arr.slice(0, idx);
      return arr.slice(idx).concat(sliced);
    };

    ArrayMethods.prototype.sample = function(arr, n, range) {
      var ary, idx, len, ridx, tmp;
      if (range == null) {
        range = void 0;
      }
      len = arr.length;
      if (n === void 0) {
        return arr[__rand(len)];
      }
      n = __int(n);
      if (n < 0) {
        _err.throw_argument();
      }
      if (n > len) {
        n = len;
      }
      ary = arr.slice(0);
      idx = -1;
      while (++idx < n) {
        ridx = idx + __rand(len - idx);
        tmp = ary[idx];
        ary[idx] = ary[ridx];
        ary[ridx] = tmp;
      }
      return ary.slice(0, n);
    };

    ArrayMethods.prototype.shuffle = function(arr) {
      var ary, idx, len, rnd, tmp;
      len = arr.length;
      ary = new Array(len);
      idx = -1;
      while (++idx < len) {
        rnd = idx + __rand(len - idx);
        tmp = arr[idx];
        ary[idx] = arr[rnd];
        ary[rnd] = tmp;
      }
      return ary;
    };

    ArrayMethods.prototype.slice = function(arr, idx, length) {
      var range, range_end, range_lenth, range_start, size;
      if (idx === null) {
        _err.throw_type();
      }
      size = arr.length;
      if ((idx != null ? idx.is_range : void 0) != null) {
        range = idx;
        range_start = __int(range.begin());
        range_end = __int(range.end());
        if (range_start < 0) {
          range_start = range_start + size;
        }
        if (range_end < 0) {
          range_end = range_end + size;
        }
        if (!range.exclude_end()) {
          range_end = range_end + 1;
        }
        range_lenth = range_end - range_start;
        if (range_start > size || range_start < 0) {
          return null;
        }
        return arr.slice(range_start, range_end);
      } else {
        idx = __int(idx);
      }
      if (idx < 0) {
        idx = size + idx;
      }
      if (length === void 0) {
        if (idx < 0 || idx >= size) {
          return null;
        }
        return arr[idx];
      } else {
        length = __int(length);
        if (idx < 0 || idx > size || length < 0) {
          return null;
        }
        return arr.slice(idx, length + idx);
      }
    };

    ArrayMethods.prototype.transpose = function(arr) {
      var ary, entry, idx, len, max, out, _j, _len1;
      if (arr.length === 0) {
        return [];
      }
      out = [];
      max = null;
      for (_j = 0, _len1 = arr.length; _j < _len1; _j++) {
        ary = arr[_j];
        ary = __arr(ary);
        max || (max = ary.length);
        if (ary.length !== max) {
          _err.throw_index();
        }
        idx = -1;
        len = ary.length;
        while (++idx < len) {
          if (!out[idx]) {
            out.push([]);
          }
          entry = out[idx];
          entry.push(ary[idx]);
        }
      }
      return out;
    };

    ArrayMethods.prototype.uniq = function(arr) {
      var ary, el, idx, len;
      idx = -1;
      len = arr.length;
      ary = [];
      while (++idx < len) {
        el = arr[idx];
        if (ary.indexOf(el) < 0) {
          ary.push(el);
        }
      }
      return ary;
    };

    ArrayMethods.prototype.unshift = function() {
      var args, arr;
      arr = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return args.concat(arr);
    };

    ArrayMethods.prototype.union = function(arr, other) {
      return _arr.uniq(arr.concat(__arr(other)));
    };

    ArrayMethods.prototype.values_at = function(arr) {
      var ary, idx, len;
      len = arguments.length;
      ary = new Array(len - 1);
      idx = 1;
      while (idx < len) {
        ary[idx - 1] = _arr.at(arr, __int(arguments[idx])) || null;
        idx += 1;
      }
      return ary;
    };

    ArrayMethods.prototype.find_index = function(arr, value) {
      var block, idx, len;
      len = arr.length;
      idx = -1;
      if (typeof value === 'function' || (typeof value === 'object' && (value.call != null))) {
        block = Block.splat_arguments(value);
      } else if (value !== null && typeof value === 'object') {
        block = function(el) {
          return __equals(value, el);
        };
      } else {
        while (++idx < len) {
          if (arr[idx] === value) {
            return idx;
          }
        }
        return null;
      }
      while (++idx < len) {
        if (block(arr[idx])) {
          return idx;
        }
      }
      return null;
    };

    ArrayMethods.prototype.map = function(arr, block) {
      var ary, callback, idx, len;
      callback = Block.splat_arguments(block);
      idx = -1;
      len = arr.length;
      ary = new Array(len);
      while (++idx < len) {
        ary[idx] = callback(arr[idx]);
      }
      return ary;
    };

    ArrayMethods.prototype.take = ArrayMethods.prototype.first;

    ArrayMethods.prototype.__native_array_with__ = function(size, obj) {
      var ary, idx;
      ary = nativeArray(__int(size));
      idx = -1;
      while (++idx < size) {
        ary[idx] = obj;
      }
      return ary;
    };

    return ArrayMethods;

  })(EnumerableMethods);

  _arr = R._arr = function(arr) {
    return new RWrapper(arr, _arr);
  };

  R.extend(_arr, new ArrayMethods());

  StringMethods = (function() {
    function StringMethods() {}

    StringMethods.prototype.equals = function(str, other) {
      if (typeof str === 'object') {
        str = str.valueOf();
      }
      if (typeof other === 'object') {
        other = other.valueOf();
      }
      return str === other;
    };

    StringMethods.prototype.camel_case = function(str) {
      return str.replace(/([\:\-\_]+(.))/g, function(_1, _2, letter, offset) {
        if (offset) {
          return letter.toUpperCase();
        } else {
          return letter;
        }
      });
    };

    StringMethods.prototype.capitalize = function(str) {
      var a, b;
      if (str.length === 0) {
        return "";
      }
      b = _str.downcase(str);
      a = _str.upcase(str[0]);
      return a + nativeStrSlice.call(b, 1);
    };

    StringMethods.prototype.center = function(str, length, padString) {
      var lft, max, rgt, size;
      if (padString == null) {
        padString = ' ';
      }
      if (padString.length === 0) {
        _err.throw_argument();
      }
      size = str.length;
      if (size >= length) {
        return str;
      }
      lft = Math.floor((length - size) / 2);
      rgt = length - size - lft;
      max = lft > rgt ? lft : rgt;
      padString = _str.multiply(padString, max);
      return padString.slice(0, lft) + str + padString.slice(0, rgt);
    };

    StringMethods.prototype.chars = function(str, block) {
      var idx, len;
      idx = -1;
      len = str.length;
      while (++idx < len) {
        block(str[idx]);
      }
      return str;
    };

    StringMethods.prototype.chomp = function(str, sep) {
      var ending, regexp, _ref2;
      if (sep == null) {
        sep = null;
      }
      if (sep === null) {
        if (_str.empty(str)) {
          return "";
        } else {
          return null;
        }
      } else {
        sep = __str(sep);
        if (sep.length === 0) {
          regexp = /((\r\n)|\n)+$/;
        } else if (sep === "\n" || sep === "\r" || sep === "\r\n") {
          ending = ((_ref2 = nativeStrMatch.call(str, /((\r\n)|\n|\r)$/)) != null ? _ref2[0] : void 0) || "\n";
          regexp = new RegExp("(" + (_rgx.escape(ending)) + ")$");
        } else {
          regexp = new RegExp("(" + (_rgx.escape(sep)) + ")$");
        }
        return str.replace(regexp, '');
      }
    };

    StringMethods.prototype.chop = function(str) {
      if (str.length === 0) {
        return str;
      }
      if (str.lastIndexOf("\r\n") === str.length - 2) {
        return str.replace(/\r\n$/, '');
      } else {
        return _str.slice(str, 0, str.length - 1);
      }
    };

    StringMethods.prototype.count = function(str) {
      var args;
      if (arguments.length === 1) {
        _err.throw_argument("String.count needs arguments");
      }
      args = _coerce.split_args(arguments, 1);
      return _str.__matched__(str, args).length;
    };

    StringMethods.prototype['delete'] = function(str) {
      var args, trash;
      if (arguments.length === 1) {
        _err.throw_argument();
      }
      args = _coerce.split_args(arguments, 1);
      trash = _str.__matched__(str, args);
      return str.replace(new RegExp("[" + trash + "]", 'g'), '');
    };

    StringMethods.prototype.each_line = function(str, separator, block) {
      var dup, lft, remainder, rgt;
      if (block == null) {
        if (separator != null) {
          if (separator.call != null) {
            block = separator;
            separator = null;
          }
        } else {
          block(str);
          return;
        }
      }
      separator || (separator = R['$/']);
      if (separator.length === 0) {
        separator = "\n\n";
      }
      lft = 0;
      rgt = null;
      dup = str;
      while ((rgt = _str.index(dup, separator, lft)) !== null) {
        rgt = rgt + 1;
        str = _str.slice(dup, lft, rgt - lft);
        lft = rgt;
        block(str);
      }
      remainder = nativeStrSlice.call(dup, lft);
      if (remainder != null) {
        if (remainder.length !== 0) {
          block(remainder);
        }
      }
      return this;
    };

    StringMethods.prototype.downcase = function(str) {
      if (!nativeStrMatch.call(str, /[A-Z]/)) {
        return str;
      }
      return str.replace(/[A-Z]/g, function(ch) {
        return String.fromCharCode(ch.charCodeAt(0) | 32);
      });
    };

    StringMethods.prototype.dump = function(str) {
      var escaped;
      escaped = str.replace(/[\f]/g, '\\f').replace(/["]/g, "\\\"").replace(/[\n]/g, '\\n').replace(/[\r]/g, '\\r').replace(/[\t]/g, '\\t');
      return "\"" + escaped + "\"";
    };

    StringMethods.prototype.empty = function(str) {
      return str.length === 0;
    };

    StringMethods.prototype.end_with = function(str) {
      var e, needles, w, _j, _len1;
      needles = _coerce.split_args(arguments, 1);
      for (_j = 0, _len1 = needles.length; _j < _len1; _j++) {
        w = needles[_j];
        try {
          w = __str(w);
          if (str.lastIndexOf(w) + w.length === str.length) {
            return true;
          }
        } catch (_error) {
          e = _error;
        }
      }
      return false;
    };

    StringMethods.prototype.gsub = function(str, pattern, replacement) {
      var pattern_lit;
      if (pattern === null) {
        _err.throw_type();
      }
      pattern_lit = __try_str(pattern);
      if (pattern_lit !== null) {
        pattern = new RegExp(_rgx.escape(pattern_lit), 'g');
      }
      if (!__isRgx(pattern)) {
        _err.throw_type();
      }
      if (!pattern.global) {
        throw "String#gsub: " + pattern + " has not set the global flag 'g'. " + pattern + "g";
      }
      return str.replace(pattern, replacement);
    };

    StringMethods.prototype.include = function(str, other) {
      return str.indexOf(other) >= 0;
    };

    StringMethods.prototype.index = function(str, needle, offset) {
      var idx;
      needle = __str(needle);
      if (offset != null) {
        offset = __int(offset);
        if (offset < 0) {
          offset = str.length + offset;
        }
      }
      if ((offset != null) && (offset > str.length || offset < 0)) {
        return null;
      }
      idx = str.indexOf(needle, offset);
      if (idx < 0) {
        return null;
      } else {
        return idx;
      }
    };

    StringMethods.prototype.insert = function(str, idx, other) {
      var after, before, chrs, insert;
      if (idx < 0) {
        idx = str.length - Math.abs(idx) + 1;
      }
      if (idx < 0 || idx > str.length) {
        _err.throw_index();
      }
      chrs = str.split("");
      before = chrs.slice(0, idx);
      insert = other.split("");
      after = chrs.slice(idx);
      return before.concat(insert).concat(after).join('');
    };

    StringMethods.prototype.ljust = function(str, width, padString) {
      var idx, len, out, pad_length;
      if (padString == null) {
        padString = " ";
      }
      len = str.length;
      if (len >= width) {
        return str;
      } else {
        if (padString.length === 0) {
          _err.throw_argument();
        }
        pad_length = width - len;
        idx = -1;
        out = "";
        while (++idx <= pad_length) {
          out += padString;
        }
        return str + out.slice(0, pad_length);
      }
    };

    StringMethods.prototype.lstrip = function(str) {
      return str.replace(/^[\s\n\t]+/g, '');
    };

    StringMethods.prototype.match = function(str, pattern, offset, block) {
      var matches, opts, result;
      if (offset == null) {
        offset = null;
      }
      if (block == null) {
        if ((offset != null ? offset.call : void 0) != null) {
          block = offset;
          offset = null;
        }
      }
      opts = {};
      if (offset != null) {
        opts = {
          string: str,
          offset: offset
        };
        str = nativeStrSlice.call(str, offset);
        matches = nativeStrMatch.call(str, pattern, offset);
      } else {
        matches = nativeStrMatch.call(str, pattern);
      }
      result = matches ? new R.MatchData(matches, opts) : null;
      R['$~'] = result;
      if (block) {
        if (result) {
          return block(result);
        } else {
          return [];
        }
      } else {
        return result;
      }
    };

    StringMethods.prototype.multiply = function(str, num) {
      var n, out, _j;
      if (num < 0) {
        _err.throw_argument();
      }
      out = "";
      for (n = _j = 0; 0 <= num ? _j < num : _j > num; n = 0 <= num ? ++_j : --_j) {
        out += str;
      }
      return out;
    };

    StringMethods.prototype.partition = function(str, pattern) {
      var a, b, c, idx, start;
      idx = _str.index(str, pattern);
      if (idx !== null) {
        start = idx + pattern.length;
        a = _str.slice(str, 0, idx) || '';
        b = pattern;
        c = nativeStrSlice.call(str, start);
        return [a, b, c];
      } else {
        return [str, '', ''];
      }
    };

    StringMethods.prototype.reverse = function(str) {
      return str.split("").reverse().join("");
    };

    StringMethods.prototype.rindex = function(str, needle, offset) {
      var ret;
      if (offset !== void 0) {
        if (offset < 0) {
          offset = offset + str.length;
        }
        if (offset < 0) {
          return null;
        }
        if (typeof needle === 'string') {
          offset = offset + needle.length;
          ret = str.slice(0, offset).lastIndexOf(needle);
        } else {
          ret = _str.__rindex_with_regexp__(str, needle, offset);
        }
      } else {
        if (typeof needle === 'string') {
          ret = str.lastIndexOf(needle);
        } else {
          ret = _str.__rindex_with_regexp__(str, needle);
        }
      }
      if (ret === -1) {
        return null;
      } else {
        return ret;
      }
    };

    StringMethods.prototype.__rindex_with_regexp__ = function(str, needle, offset) {
      var idx, result, stop;
      if (!needle.global) {
        needle = new RegExp(needle.source, "g" + (needle.ignoreCase ? "i" : "") + (needle.multiLine ? "m" : ""));
      }
      if (offset == null) {
        offset = str.length;
      }
      idx = -1;
      stop = 0;
      while ((result = needle.exec(str)) !== null) {
        if (result.index > offset) {
          break;
        }
        idx = result.index;
        needle.lastIndex = ++stop;
      }
      return idx;
    };

    StringMethods.prototype.rjust = function(str, width, pad_str) {
      var len, pad_len;
      if (pad_str == null) {
        pad_str = " ";
      }
      width = __int(width);
      len = str.length;
      if (len >= width) {
        return str;
      } else {
        pad_str = __str(pad_str);
        if (pad_str.length === 0) {
          _err.throw_argument();
        }
        pad_len = width - len;
        return _str.multiply(pad_str, pad_len).slice(0, pad_len) + str;
      }
    };

    StringMethods.prototype.rpartition = function(str, pattern) {
      var a, b, c, idx, len, start;
      pattern = __str(pattern);
      idx = _str.rindex(str, pattern);
      if (idx !== null) {
        start = idx + pattern.length;
        len = str.length - start;
        a = str.slice(0, idx);
        b = pattern;
        c = str.slice(start);
        return [a, b, c];
      } else {
        return ['', '', str];
      }
    };

    StringMethods.prototype.rstrip = function(str) {
      return str.replace(/[\s\n\t]+$/g, '');
    };

    StringMethods.prototype.scan = function(str, pattern, block) {
      var fin, index, match, match_arr, val;
      if (block == null) {
        block = null;
      }
      if (!__isRgx(pattern)) {
        pattern = __str(pattern);
        pattern = _rgx.quote(pattern);
      }
      index = 0;
      R['$~'] = null;
      match_arr = block !== null ? str : [];
      while (match = str.slice(index).match(pattern)) {
        fin = index + match.index + match[0].length;
        if (match[0].length === 0) {
          fin += 1;
        }
        R['$~'] = new R.MatchData(match, {
          offset: index,
          string: str
        });
        if (match.length > 1) {
          val = match.slice(1, match.length);
        } else {
          val = [match[0]];
        }
        if (block !== null) {
          block(val);
        } else {
          if (match.length === 1) {
            val = val[0];
          }
          match_arr.push(val);
        }
        index = fin;
        if (index > str.length) {
          break;
        }
      }
      if (block !== null) {
        return str;
      } else {
        return match_arr;
      }
    };

    StringMethods.prototype.squeeze = function(str) {
      var all, c, chars, i, j, last, len, pattern, trash;
      pattern = _coerce.split_args(arguments, 1);
      trash = _str.__matched__(str, pattern);
      chars = str.split("");
      len = str.length;
      i = 1;
      j = 0;
      last = chars[0];
      all = pattern.length === 0;
      while (i < len) {
        c = chars[i];
        if (!(c === last && (all || trash.indexOf(c) >= 0))) {
          chars[j += 1] = last = c;
        }
        i += 1;
      }
      if ((j + 1) < len) {
        chars = chars.slice(0, +j + 1 || 9e9);
      }
      return chars.join('');
    };

    StringMethods.prototype.strip = function(str) {
      return _str.rstrip(_str.lstrip(str));
    };

    StringMethods.prototype.sub = function(str, pattern, replacement) {
      var pattern_lit;
      if (pattern === null) {
        _err.throw_type();
      }
      pattern_lit = __try_str(pattern);
      if (pattern_lit !== null) {
        pattern = new RegExp(_rgx.escape(pattern_lit));
      }
      if (!__isRgx(pattern)) {
        _err.throw_type();
      }
      if (pattern.global) {
        throw "String#sub: " + pattern + " has set the global flag 'g'. " + pattern + "g";
      }
      return str.replace(pattern, replacement);
    };

    StringMethods.prototype.succ = function(str) {
      var c, carry, chars, codes, last_alnum, s, start;
      if (str.length === 0) {
        return '';
      }
      codes = (function() {
        var _j, _len1, _ref2, _results;
        _ref2 = str.split("");
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          c = _ref2[_j];
          _results.push(c.charCodeAt(0));
        }
        return _results;
      })();
      carry = null;
      last_alnum = 0;
      start = codes.length - 1;
      while (start >= 0) {
        s = codes[start];
        if (nativeString.fromCharCode(s).match(/[a-zA-Z0-9]/) !== null) {
          carry = 0;
          if ((48 <= s && s < 57) || (97 <= s && s < 122) || (65 <= s && s < 90)) {
            codes[start] = codes[start] + 1;
          } else if (s === 57) {
            codes[start] = 48;
            carry = 49;
          } else if (s === 122) {
            codes[start] = carry = 97;
          } else if (s === 90) {
            codes[start] = carry = 65;
          }
          if (carry === 0) {
            break;
          }
          last_alnum = start;
        }
        start -= 1;
      }
      if (carry === null) {
        start = codes.length - 1;
        carry = 1;
        while (start >= 0) {
          s = codes[start];
          if (s >= 255) {
            codes[start] = 0;
          } else {
            codes[start] = codes[start] + 1;
            break;
          }
          start -= 1;
        }
      }
      chars = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = codes.length; _j < _len1; _j++) {
          c = codes[_j];
          _results.push(String.fromCharCode(c));
        }
        return _results;
      })();
      if (start < 0) {
        chars[last_alnum] = nativeString.fromCharCode(carry, codes[last_alnum]);
      }
      return chars.join("");
    };

    StringMethods.prototype.slice = function(str, index, other) {
      var length, size, start;
      if (index === null) {
        _err.throw_type();
      }
      size = str.length;
      if (other !== void 0) {
        if (index.is_regexp != null) {
          _err.throw_not_implemented();
        } else {
          length = other;
          start = index;
          if (start < 0) {
            start += size;
          }
          if (length < 0 || start < 0 || start > size) {
            return null;
          }
          return nativeStrSlice.call(str, start, start + length);
        }
      }
      if (index.is_regexp != null) {
        return _err.throw_not_implemented();
      } else if (typeof index === 'string') {
        if (_str.include(str, index)) {
          return index;
        } else {
          return null;
        }
      } else if (index.is_range != null) {
        start = __int(index.begin());
        length = __int(index.end());
        if (start < 0) {
          start += size;
        }
        if (length < 0) {
          length += size;
        }
        if (!index.exclude_end()) {
          length += 1;
        }
        if (start === size) {
          return "";
        }
        if (start < 0 || start > size) {
          return null;
        }
        if (length > size) {
          length = size;
        }
        length = length - start;
        if (length < 0) {
          length = 0;
        }
        return nativeStrSlice.call(str, start, start + length);
      } else {
        if (index < 0) {
          index += size;
        }
        if (index < 0 || index >= size) {
          return null;
        }
        return str[index];
      }
    };

    StringMethods.prototype.split = function(str, pattern, limit) {
      var ary, el, tmp, _j, _len1;
      if (pattern == null) {
        pattern = " ";
      }
      if (typeof pattern !== 'string') {
        pattern = pattern.valueOf();
      }
      ary = str.split(pattern);
      while (__truthy(str = ary[ary.length - 1])) {
        if (str.length !== 0) {
          break;
        }
        ary.pop();
      }
      if (pattern === ' ') {
        tmp = [];
        for (_j = 0, _len1 = ary.length; _j < _len1; _j++) {
          el = ary[_j];
          if (el !== '') {
            tmp.push(el);
          }
        }
        ary = tmp;
      }
      return ary;
    };

    StringMethods.prototype.start_with = function(str) {
      var e, needle, needles, _j, _len1;
      needles = _coerce.split_args(arguments, 1);
      for (_j = 0, _len1 = needles.length; _j < _len1; _j++) {
        needle = needles[_j];
        try {
          needle = __str(needle);
          if (str.indexOf(needle) === 0) {
            return true;
          }
        } catch (_error) {
          e = _error;
        }
      }
      return false;
    };

    StringMethods.prototype.swapcase = function(str) {
      if (!str.match(/[a-zA-Z]/)) {
        return str;
      }
      return str.replace(/[a-zA-Z]/g, function(ch) {
        var code, swap;
        code = ch.charCodeAt(0);
        swap = code < 97 ? code | 32 : code & ~32;
        return String.fromCharCode(swap);
      });
    };

    StringMethods.prototype.to_i = function(str, base) {
      var lit;
      if (base === void 0) {
        base = 10;
      }
      base = __int(base);
      if (base < 0 || base > 36 || base === 1) {
        _err.throw_argument();
      }
      lit = _str.strip(str);
      if (!lit.match(/^([\+\-]?)([^\+^\-_]+)/)) {
        return 0;
      }
      lit = lit.replace(/_/g, '');
      return parseInt(lit, base);
    };

    StringMethods.prototype.to_f = function(str) {
      var number_match, number_string, _ref2;
      number_match = str.match(/^([\+\-]?[_\d\.]+)([Ee\+\-\d]+)?/);
      number_string = (_ref2 = number_match != null ? number_match[0] : void 0) != null ? _ref2 : "0.0";
      return Number(number_string.replace(/_/g, ''));
    };

    StringMethods.prototype.upcase = function(str) {
      if (!str.match(/[a-z]/)) {
        return str;
      }
      return str.replace(/[a-z]/g, function(ch) {
        return String.fromCharCode(ch.charCodeAt(0) & ~32);
      });
    };

    StringMethods.prototype.upto = function(str, stop, exclusive, block) {
      var orig, stop_size;
      stop = __str(stop);
      exclusive || (exclusive = false);
      if (block === void 0 && ((exclusive != null ? exclusive.call : void 0) != null)) {
        block = exclusive;
        exclusive = false;
      }
      orig = str;
      stop_size = stop.length;
      exclusive = exclusive === true;
      while ((str < stop || (!exclusive && str === stop)) && !(str.length > stop_size)) {
        block(str);
        str = _str.succ(str);
      }
      return orig;
    };

    StringMethods.prototype.__matched__ = function(str, args) {
      var el, rgx, _j, _len1;
      for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
        el = args[_j];
        rgx = _str.__to_regexp__(el);
        str = (nativeStrMatch.call(str, rgx) || []).join('');
      }
      return str;
    };

    StringMethods.prototype.__to_regexp__ = function(str) {
      var e, r;
      r = "";
      if (str.length === 0) {
        r = "(?!)";
      } else if (str === '^') {
        r = "\\^";
      } else {
        if (str.lastIndexOf("^") >= 1) {
          str = str[0] + str.slice(1).replace("^", "\\^");
        }
        r = "[" + str + "]";
      }
      try {
        return new RegExp(r, 'g');
      } catch (_error) {
        e = _error;
        return _err.throw_argument();
      }
    };

    return StringMethods;

  })();

  _str = R._str = function(str) {
    return new RWrapper(str, _str);
  };

  R.extend(_str, new StringMethods());

  RegexpMethods = (function() {
    function RegexpMethods() {}

    RegexpMethods.prototype.escape = function(pattern) {
      pattern = __str(pattern);
      return pattern.replace(/([.?*+^$[\](){}|-])/g, "\\$1").replace(/[\f]/g, '\\f').replace(/[\n]/g, '\\n').replace(/[\r]/g, '\\r').replace(/[\t]/g, '\\t').replace(/[\s]/g, '\\ ');
    };

    RegexpMethods.prototype.quote = function(pattern) {
      return _rgx.escape(pattern);
    };

    return RegexpMethods;

  })();

  _rgx = R._rgx = function(rgx) {
    return new R.Regexp(rgx);
  };

  R.extend(_rgx, new RegexpMethods());

  HashMethods = (function(_super) {
    __extends(HashMethods, _super);

    function HashMethods() {
      _ref2 = HashMethods.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    HashMethods.prototype.assoc = function(hsh, needle) {
      var k, v;
      if (typeof needle === 'object' && (needle.equals != null)) {
        for (k in hsh) {
          if (!__hasProp.call(hsh, k)) continue;
          v = hsh[k];
          if (needle.equals(k)) {
            return [k, v];
          }
        }
      } else {
        for (k in hsh) {
          if (!__hasProp.call(hsh, k)) continue;
          v = hsh[k];
          if (needle === k) {
            return [k, v];
          }
        }
      }
      return null;
    };

    HashMethods.prototype["delete"] = function(hsh, key, block) {
      var value;
      if (key in hsh) {
        value = hsh[key];
        delete hsh[key];
        return value;
      } else {
        if ((block != null ? block.call : void 0) != null) {
          return block(key);
        } else {
          return null;
        }
      }
    };

    HashMethods.prototype.delete_if = function(hsh, block) {
      var k, v;
      if ((block != null ? block.call : void 0) != null) {
        for (k in hsh) {
          if (!__hasProp.call(hsh, k)) continue;
          v = hsh[k];
          if (block(k, v)) {
            delete hsh[k];
          }
        }
        return hsh;
      } else {

      }
    };

    HashMethods.prototype.each = function(hsh, block) {
      var k, v;
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        block(k, v);
      }
      return hsh;
    };

    HashMethods.prototype.each_key = function(hsh, block) {
      var k, v;
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        block(k);
      }
      return hsh;
    };

    HashMethods.prototype.each_value = function(hsh, block) {
      var k, v;
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        block(v);
      }
      return hsh;
    };

    HashMethods.prototype.empty = function(hsh) {
      var k, v;
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        return false;
      }
      return true;
    };

    HashMethods.prototype.fetch = function(hsh, key, default_value) {
      var _ref3;
      if (arguments.length <= 1) {
        _err.throw_argument();
      }
      if (key in hsh) {
        return hsh[key];
      } else if (((default_value != null ? default_value.call : void 0) != null) || (((_ref3 = arguments[3]) != null ? _ref3.call : void 0) != null)) {
        return (arguments[3] || default_value)(key);
      } else if (default_value !== void 0) {
        return default_value;
      } else {
        return _err.throw_key();
      }
    };

    HashMethods.prototype.flatten = function(hsh, recursion) {
      if (recursion == null) {
        recursion = 1;
      }
      recursion = __int(recursion);
      return _arr.flatten(_hsh.to_a(hsh), recursion);
    };

    HashMethods.prototype.get = function(hsh, key) {
      return hsh[key];
    };

    HashMethods.prototype.has_value = function(hsh, val) {
      var k, v;
      if (typeof val === 'object' && (val.equals != null)) {
        for (k in hsh) {
          if (!__hasProp.call(hsh, k)) continue;
          v = hsh[k];
          if (val.equals(v)) {
            return true;
          }
        }
      } else {
        for (k in hsh) {
          if (!__hasProp.call(hsh, k)) continue;
          v = hsh[k];
          if (v === val) {
            return true;
          }
        }
      }
      return false;
    };

    HashMethods.prototype.has_key = function(hsh, key) {
      return key in hsh;
    };

    HashMethods.prototype.include = HashMethods.prototype.has_key;

    HashMethods.prototype.member = HashMethods.prototype.has_key;

    HashMethods.prototype.keep_if = function(hsh, block) {
      _hsh.reject$(hsh, block);
      return hsh;
    };

    HashMethods.prototype.key = function(hsh, value) {
      var k, v;
      if (typeof value === 'object' && (value.equals != null)) {
        for (k in hsh) {
          if (!__hasProp.call(hsh, k)) continue;
          v = hsh[k];
          if (value.equals(v)) {
            return k;
          }
        }
      } else {
        for (k in hsh) {
          if (!__hasProp.call(hsh, k)) continue;
          v = hsh[k];
          if (v === value) {
            return k;
          }
        }
      }
      return null;
    };

    HashMethods.prototype.invert = function(hsh) {
      var k, ret, v;
      ret = {};
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        ret[v] = k;
      }
      return ret;
    };

    HashMethods.prototype.keys = function(hsh) {
      var k, v, _results;
      _results = [];
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        _results.push(k);
      }
      return _results;
    };

    HashMethods.prototype.merge = function(hsh, other, block) {
      var k, out, v;
      out = {};
      if (other.rubyjs != null) {
        other = other.__native__;
      }
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        out[k] = v;
      }
      for (k in other) {
        if (!__hasProp.call(other, k)) continue;
        v = other[k];
        if (((block != null ? block.call : void 0) != null) && k in out) {
          out[k] = block(k, out[k], v);
        } else {
          out[k] = v;
        }
      }
      return out;
    };

    HashMethods.prototype.merge$ = function(hsh, other, block) {
      var k, v;
      if (other.rubyjs != null) {
        other = other.__native__;
      }
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        hsh[k] = v;
      }
      for (k in other) {
        if (!__hasProp.call(other, k)) continue;
        v = other[k];
        if (((block != null ? block.call : void 0) != null) && k in hsh) {
          hsh[k] = block(k, hsh[k], v);
        } else {
          hsh[k] = v;
        }
      }
      return hsh;
    };

    HashMethods.prototype.rassoc = function(hsh, needle) {
      var k, v;
      if (typeof needle === 'object' && (needle.equals != null)) {
        for (k in hsh) {
          if (!__hasProp.call(hsh, k)) continue;
          v = hsh[k];
          if (needle.equals(v)) {
            return [k, v];
          }
        }
      } else {
        for (k in hsh) {
          if (!__hasProp.call(hsh, k)) continue;
          v = hsh[k];
          if (needle === v) {
            return [k, v];
          }
        }
      }
      return null;
    };

    HashMethods.prototype.reject = function(hsh, block) {
      var dup, k, v;
      dup = {};
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        if (!block(k, v)) {
          dup[k] = v;
        }
      }
      return dup;
    };

    HashMethods.prototype.reject$ = function(hsh, block) {
      var changed, k, v;
      changed = false;
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        if (!block(k, v)) {
          delete hsh[k];
          changed = true;
        }
      }
      if (changed) {
        return hsh;
      } else {
        return null;
      }
    };

    HashMethods.prototype.select = function(hsh, block) {
      var dup, k, v;
      dup = {};
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        if (block(k, v)) {
          dup[k] = v;
        }
      }
      return dup;
    };

    HashMethods.prototype.select$ = function(hsh, block) {
      var changed, k, v;
      changed = false;
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        if (block(k, v)) {
          delete hsh[k];
          changed = true;
        }
      }
      if (changed) {
        return hsh;
      } else {
        return null;
      }
    };

    HashMethods.prototype.size = function(hsh) {
      var counter, k, v;
      counter = 0;
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        counter += 1;
      }
      return counter;
    };

    HashMethods.prototype.sort = function(hsh, block) {
      return _arr.sort(_hsh.to_a(hsh), block);
    };

    HashMethods.prototype.to_a = function(hsh) {
      var k, v, _results;
      _results = [];
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        _results.push([k, v]);
      }
      return _results;
    };

    HashMethods.prototype.values = function(hsh) {
      var k, v, _results;
      _results = [];
      for (k in hsh) {
        if (!__hasProp.call(hsh, k)) continue;
        v = hsh[k];
        _results.push(v);
      }
      return _results;
    };

    HashMethods.prototype.values_at = function() {
      var hsh, k, keys, _j, _len1, _results;
      hsh = arguments[0], keys = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _results = [];
      for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
        k = keys[_j];
        _results.push(hsh[k]);
      }
      return _results;
    };

    return HashMethods;

  })(EnumerableMethods);

  _hsh = R._hsh = function(arr) {
    return new RHash(arr);
  };

  R.extend(_hsh, new HashMethods());

  TimeMethods = (function() {
    function TimeMethods() {}

    TimeMethods.prototype._rjust = function(fixnum, str) {
      if (str == null) {
        str = '0';
      }
      return _str.rjust(fixnum + "", 2, str);
    };

    TimeMethods.prototype.strftime = function(date, format) {
      var fill, locale, out;
      locale = R.Time.LOCALE;
      fill = _time._rjust;
      out = format.replace(/%(.)/g, function(_, flag) {
        var day, jtime;
        switch (flag) {
          case 'a':
            return locale.DAYS_SHORT[_time.wday(date)];
          case 'A':
            return locale.DAYS[_time.wday(date)];
          case 'b':
            return locale.MONTHS_SHORT[_time.month(date)];
          case 'B':
            return locale.MONTHS[_time.month(date)];
          case 'C':
            return _time.year(date) % 100;
          case 'd':
            return fill(_time.day(date));
          case 'D':
            return _time.strftime(date, '%m/%d/%y');
          case 'e':
            return fill(_time.day(date), ' ');
          case 'F':
            return _time.strftime(date, '%Y-%m-%d');
          case 'h':
            return locale.MONTHS_SHORT[_time.month(date)];
          case 'H':
            return fill(_time.hour(date));
          case 'I':
            return fill(_time.hour12(date));
          case 'j':
            jtime = new Date(_time.year(date), 0, 1).getTime();
            return Math.ceil((date.getTime() - jtime) / (1000 * 60 * 60 * 24));
          case 'k':
            return _str.rjust("" + _time.hour(date), 2, ' ');
          case 'l':
            return fill(_time.hour12(date), ' ');
          case 'm':
            return fill(_time.month(date));
          case 'M':
            return fill(_time.min(date));
          case 'n':
            return "\n";
          case 'N':
            return _err.throw_not_implemented();
          case 'p':
            if (_time.hour(date) < 12) {
              return locale.AM;
            } else {
              return locale.PM;
            }
            break;
          case 'P':
            if (_time.hour(date) < 12) {
              return locale.AM_LOW;
            } else {
              return locale.PM_LOW;
            }
            break;
          case 'r':
            return _time.strftime(date, '%I:%M:%S %p');
          case 'R':
            return _time.strftime(date, '%H:%M');
          case 'S':
            return fill(_time.sec(date));
          case 's':
            return Math.floor((date.getTime()) / 1000);
          case 't':
            return "\t";
          case 'T':
            return _time.strftime(date, '%H:%M:%S');
          case 'u':
            day = _time.wday(date);
            if (day === 0) {
              return 7;
            } else {
              return day;
            }
            break;
          case 'v':
            return _time.strftime(date, '%e-%b-%Y');
          case 'w':
            return _time.wday(date);
          case 'y':
            return _str.slice(_time.year(date) + "", -2, 2);
          case 'Y':
            return _time.year(date);
          case 'x':
            return _time.strftime(date, '%m/%d/%y');
          case 'X':
            return _time.strftime(date, '%H:%M:%S');
          case 'z':
            return _time._offset_str(date);
          case 'Z':
            return _time.zone(date);
          default:
            return flag;
        }
      });
      return out;
    };

    TimeMethods.prototype.asctime = function(date) {
      return _time.strftime(date, "%a %b %e %H:%M:%S %Y");
    };

    TimeMethods.prototype.ctime = TimeMethods.prototype.asctime;

    TimeMethods.prototype.year = function(date) {
      return date.getFullYear();
    };

    TimeMethods.prototype.month = function(date) {
      return date.getMonth() + 1;
    };

    TimeMethods.prototype.mon = TimeMethods.prototype.month;

    TimeMethods.prototype.monday = function(date) {
      return _time.wday(date) === 1;
    };

    TimeMethods.prototype.tuesday = function(date) {
      return _time.wday(date) === 2;
    };

    TimeMethods.prototype.wednesday = function(date) {
      return _time.wday(date) === 3;
    };

    TimeMethods.prototype.thursday = function(date) {
      return _time.wday(date) === 4;
    };

    TimeMethods.prototype.friday = function(date) {
      return _time.wday(date) === 5;
    };

    TimeMethods.prototype.saturday = function(date) {
      return _time.wday(date) === 6;
    };

    TimeMethods.prototype.sunday = function(date) {
      return _time.wday(date) === 0;
    };

    TimeMethods.prototype.day = function(date) {
      return date.getDate();
    };

    TimeMethods.prototype.mday = TimeMethods.prototype.day;

    TimeMethods.prototype.hour = function(date) {
      return date.getHours();
    };

    TimeMethods.prototype.hour12 = function(date) {
      return date.getHours() % 12;
    };

    TimeMethods.prototype.min = function(date) {
      return date.getMinutes();
    };

    TimeMethods.prototype.sec = function(date) {
      return date.getSeconds();
    };

    TimeMethods.prototype.tv_usec = function(date) {
      return (date.valueOf() % 1000) * 1000;
    };

    TimeMethods.prototype.usec = TimeMethods.prototype.tv_usec;

    TimeMethods.prototype.wday = function(date) {
      return date.getDay();
    };

    TimeMethods.prototype.yday = function(date) {
      var secs;
      secs = date.getTime();
      return Math.floor(secs / 86400000);
    };

    TimeMethods.prototype.gmt_offset = function(date) {
      return date.getTimezoneOffset() * -60;
    };

    TimeMethods.prototype._offset_str = function(date) {
      var hour, mins, offset, sign;
      offset = _time.gmt_offset(date);
      mins = offset / 60;
      if (mins === 0) {
        return '+0000';
      }
      sign = mins > 0 ? '+' : '-';
      mins = Math.abs(mins);
      hour = this._rjust(Math.ceil(mins / 60));
      mins = this._rjust(mins % 60);
      return sign + hour + mins;
    };

    return TimeMethods;

  })();

  _time = R._time = function(arr) {
    return new R.Time(arr);
  };

  R.extend(_time, new TimeMethods());

  RWrapper = (function() {
    function RWrapper(value, type) {
      this.value = value;
      this.type = type;
      this.chain = false;
    }

    RWrapper.prototype.valueOf = function() {
      return this.value;
    };

    return RWrapper;

  })();

  R.Wrapper = RWrapper;

  lookupFunction = function(val, name) {
    var ns;
    if (val === null) {
      return function() {
        throw new TypeError("wrapper has null value");
      };
    }
    if (this.type) {
      return this.type;
    }
    if (typeof val === 'object') {
      val = val.valueOf();
    }
    ns = null;
    if (typeof val === 'string') {
      ns = _str;
    } else if (typeof val === 'number') {
      ns = _num;
    } else if (__isArr(val)) {
      ns = _arr;
    } else {
      ns = _hsh;
    }
    return ns[name];
  };

  dispatchFunction = function(name) {
    return function() {
      var func, self, t;
      self = this;
      if (t = self.type) {
        func = t[name];
        self.type = null;
      } else {
        func = lookupFunction(self.value, name);
      }
      self.value = __call(func, self.value, arguments);
      if (self.chain) {
        return this;
      } else {
        return self.value;
      }
    };
  };

  klasses = [ArrayMethods, StringMethods, NumericMethods, TimeMethods];

  for (_j = 0, _len1 = klasses.length; _j < _len1; _j++) {
    klass = klasses[_j];
    _ref3 = klass.prototype;
    _fn1 = function(name, fn) {
      return RWrapper.prototype[name] = dispatchFunction(name);
    };
    for (name in _ref3) {
      if (!__hasProp.call(_ref3, name)) continue;
      fn = _ref3[name];
      _fn1(name, fn);
    }
  }

  RubyJS.Object = (function() {
    function Object() {}

    Object.include = RubyJS.include;

    Object.__add_default_aliases__ = function(proto) {
      if (proto['<<'] != null) {
        proto.append = proto['<<'];
      }
      if (proto['==='] != null) {
        proto.equal_case = proto['==='];
      }
      if (proto.minus != null) {
        proto['-'] = proto.minus;
      }
      if (proto.plus != null) {
        proto['+'] = proto.plus;
      }
      if (proto['%'] != null) {
        proto.modulo = proto['%'];
      }
      if (proto['*'] != null) {
        proto.multiply = proto['*'];
      }
      if (proto['**'] != null) {
        proto.exp = proto['**'];
      }
      if (proto['/'] != null) {
        return proto.divide = proto['/'];
      }
    };

    Object.include(RubyJS.Kernel);

    Object.prototype.send = function() {
      var args, method_name;
      method_name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this[method_name](args);
    };

    Object.prototype.respond_to = function(method_name) {
      return this[method_name] != null;
    };

    Object.prototype.to_enum = function() {
      var args, iter;
      iter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (iter == null) {
        iter = "each";
      }
      return new RubyJS.Enumerator(this, iter, args);
    };

    Object.prototype.tap = function(block) {
      block(this);
      return this;
    };

    Object.prototype.value = function() {
      return this.to_native.apply(this, arguments);
    };

    return Object;

  })();

  RCoerce = R._coerce = {
    single_block_args: function(args, block) {
      if (block) {
        if (block.length !== 1) {
          if (args.length > 1) {
            return nativeSlice.call(args);
          } else {
            return args[0];
          }
        } else {
          return args[0];
        }
      } else {
        if (args.length !== 1) {
          return nativeSlice.call(args);
        } else {
          return args[0];
        }
      }
    },
    coerce: function(obj, to_what, skip_native) {
      if (skip_native !== void 0 && skip_native === typeof obj) {
        return obj;
      } else {
        if (obj === null || obj === void 0) {
          throw new R.TypeError["new"]();
        }
        obj = R(obj);
        if (obj[to_what] == null) {
          throw R.TypeError["new"]("TypeError: cant't convert ... into String");
        }
        if (skip_native !== void 0) {
          return obj[to_what]().to_native();
        } else {
          return obj[to_what]();
        }
      }
    },
    to_native: function(obj) {
      if (typeof obj !== 'object') {
        return obj;
      } else {
        return obj.valueOf();
      }
    },
    to_num_native: function(obj) {
      if (typeof obj === 'number') {
        return obj;
      } else {
        obj = R(obj);
        if (obj.is_numeric == null) {
          throw R.TypeError["new"]();
        }
        return obj.to_native();
      }
    },
    to_int: function(obj) {
      return RCoerce.coerce(obj, 'to_int');
    },
    to_int_native: function(obj) {
      if (typeof obj === 'number' && (obj % 1 === 0)) {
        return obj;
      } else {
        return RCoerce.coerce(obj, 'to_int').to_native();
      }
    },
    to_str: function(obj) {
      return RCoerce.coerce(obj, 'to_str');
    },
    to_str_native: function(obj) {
      return RCoerce.coerce(obj, 'to_str', 'string');
    },
    to_ary: function(obj) {
      return this.coerce(obj, 'to_ary');
    },
    to_ary_native: function(obj) {
      if (RArray.isNativeArray(obj)) {
        return obj;
      } else {
        return RCoerce.coerce(obj, 'to_ary').to_native();
      }
    }
  };

  R.RCoerce = RCoerce;

  RubyJS.Comparable = (function() {
    function Comparable() {}

    Comparable.prototype.lt = function(other) {
      var cmp;
      cmp = this.cmp(other);
      if (cmp === null) {
        throw R.TypeError["new"]();
      }
      return cmp < 0;
    };

    Comparable.prototype.gt = function(other) {
      var cmp;
      cmp = this.cmp(other);
      if (cmp === null) {
        throw R.TypeError["new"]();
      }
      return cmp > 0;
    };

    Comparable.prototype.lteq = function(other) {
      var cmp;
      cmp = this.cmp(other);
      if (cmp === null) {
        throw R.TypeError["new"]();
      }
      return cmp <= 0;
    };

    Comparable.prototype.gteq = function(other) {
      var cmp;
      cmp = this.cmp(other);
      if (cmp === null) {
        throw R.TypeError["new"]();
      }
      return cmp >= 0;
    };

    Comparable.prototype.between = function(min, max) {
      return this.gteq(min) && this.lteq(max);
    };

    Comparable.cmp = __cmp;

    Comparable.cmpstrict = __cmpstrict;

    Comparable.prototype.gteq = Comparable.prototype.gteq;

    return Comparable;

  })();

  RubyJS.Enumerable = (function() {
    function Enumerable() {}

    Enumerable.prototype.all = function(block) {
      return _itr.all(this, block);
    };

    Enumerable.prototype.any = function(block) {
      return _itr.any(this, block);
    };

    Enumerable.prototype.collect_concat = function(block) {
      if (block == null) {
        block = null;
      }
      if (!(block && (block.call != null))) {
        return this.to_enum('collect_concat');
      }
      return new RArray(_itr.collect_concat(this, block));
    };

    Enumerable.prototype.flat_map = Enumerable.prototype.collect_concat;

    Enumerable.prototype.count = function(block) {
      return new R.Fixnum(_itr.count(this, block));
    };

    Enumerable.prototype.cycle = function(n, block) {
      if (arguments.length > 2) {
        throw R.ArgumentError["new"]();
      }
      if (!(((block != null ? block.call : void 0) != null) || ((n != null ? n.call : void 0) != null))) {
        return this.to_enum('cycle', n);
      }
      return _itr.cycle(this, n, block);
    };

    Enumerable.prototype.drop = function(n) {
      __ensure_args_length(arguments, 1);
      n = RCoerce.to_int_native(n);
      if (n < 0) {
        throw R.ArgumentError["new"]();
      }
      return new RArray(_itr.drop(this, n));
    };

    Enumerable.prototype.drop_while = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('drop_while');
      }
      return new RArray(_itr.drop_while(this, block));
    };

    Enumerable.prototype.each_cons = function() {
      var args, block, n;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = __extract_block(args);
      if (!(block && (block.call != null))) {
        return this.to_enum.apply(this, ['each_cons'].concat(__slice.call(args)));
      }
      __ensure_args_length(args, 1);
      n = RCoerce.to_int_native(args[0]);
      if (!(n > 0)) {
        throw R.ArgumentError["new"]();
      }
      return _itr.each_cons(this, n, block);
    };

    Enumerable.prototype.each_entry = function(block) {
      if (arguments.length > 1) {
        throw R.ArgumentError["new"]();
      }
      if (!(block && (block.call != null))) {
        return this.to_enum('each_entry');
      }
      return _itr.each_entry(this, block);
    };

    Enumerable.prototype.each_slice = function(n, block) {
      if (!n) {
        throw R.ArgumentError["new"]();
      }
      n = RCoerce.to_int_native(n);
      if (n <= 0) {
        throw R.ArgumentError["new"]();
      }
      if (block && (block.call == null)) {
        throw R.ArgumentError["new"]();
      }
      if (block === void 0) {
        return this.to_enum('each_slice', n);
      }
      return _itr.each_slice(this, n, block);
    };

    Enumerable.prototype.each_with_index = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('each_with_index');
      }
      return _itr.each_with_index(this, block);
    };

    Enumerable.prototype.each_with_object = function(obj, block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('each_with_object', obj);
      }
      return _itr.each_with_object(this, obj, block);
    };

    Enumerable.prototype.find = function(ifnone, block) {
      if (block == null) {
        block = null;
      }
      return _itr.find(this, ifnone, block);
    };

    Enumerable.prototype.detect = Enumerable.prototype.find;

    Enumerable.prototype.find_all = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('find_all');
      }
      return new RArray(_itr.select(this, block));
    };

    Enumerable.prototype.select = Enumerable.prototype.find_all;

    Enumerable.prototype.find_index = function(value) {
      var val;
      if (arguments.length === 0) {
        return this.to_enum('find_index');
      }
      val = _itr.find_index(this, value);
      if (val !== null) {
        return new R.Fixnum(val);
      } else {
        return val;
      }
    };

    Enumerable.prototype.first = function(n) {
      if (n === null || n === void 0) {
        return _itr.first(this, null);
      } else {
        n = RCoerce.to_int_native(n);
        return new RArray(_itr.first(this, n));
      }
    };

    Enumerable.prototype.include = function(other) {
      return _itr.include(this, other);
    };

    Enumerable.prototype.inject = function(init, sym, block) {
      return _itr.inject(this, init, sym, block);
    };

    Enumerable.prototype.iterator = function() {
      return this.each();
    };

    Enumerable.prototype.grep = function(pattern, block) {
      return new RArray(_itr.grep(this, pattern, block));
    };

    Enumerable.prototype.group_by = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('group_by');
      }
      return _itr.group_by(this, block);
    };

    Enumerable.prototype.map = function(block) {
      var arr, callback;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('map');
      }
      callback = R.blockify(block, this);
      arr = [];
      this.each(function() {
        return arr.push(callback.invoke(arguments));
      });
      return new RArray(arr);
    };

    Enumerable.prototype.collect = Enumerable.prototype.map;

    Enumerable.prototype.member = Enumerable.prototype.include;

    Enumerable.prototype.max = function(block) {
      return _itr.max(this, block);
    };

    Enumerable.prototype.max_by = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('max_by');
      }
      return _itr.max_by(this, block);
    };

    Enumerable.prototype.min = function(block) {
      return _itr.min(this, block);
    };

    Enumerable.prototype.min_by = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('min_by');
      }
      return _itr.min_by(this, block);
    };

    Enumerable.prototype.minmax = function(block) {
      return new RArray(_itr.minmax(this, block));
    };

    Enumerable.prototype.minmax_by = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('minmax_by');
      }
      return new RArray(_itr.minmax_by(this, block));
    };

    Enumerable.prototype.none = function(block) {
      return _itr.none(this, block);
    };

    Enumerable.prototype.one = function(block) {
      return _itr.one(this, block);
    };

    Enumerable.prototype.partition = function(block) {
      var ary;
      if (!(block && (block.call != null))) {
        return this.to_enum('partition');
      }
      ary = _itr.partition(this, block);
      return new RArray([ary[0], ary[1]]);
    };

    Enumerable.prototype.reduce = Enumerable.prototype.inject;

    Enumerable.prototype.reject = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('reject');
      }
      return new RArray(_itr.reject(this, block));
    };

    Enumerable.prototype.reverse_each = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('reverse_each');
      }
      return _itr.reverse_each(this, block);
    };

    Enumerable.prototype.slice_before = function() {
      var arg, args, block, has_init, self;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = __extract_block(args);
      arg = R(args[0]);
      if (block) {
        has_init = !(arg === void 0);
      } else {
        block = function(elem) {
          return arg['==='](elem);
        };
      }
      self = this;
      return R.Enumerator.create(function(yielder) {
        var accumulator;
        accumulator = null;
        self.each(function(elem) {
          var start_new;
          start_new = has_init ? block(elem, arg.dup()) : block(elem);
          if (start_new) {
            if (accumulator) {
              yielder["yield"](accumulator);
            }
            return accumulator = R([elem]);
          } else {
            accumulator || (accumulator = new RArray([]));
            return accumulator.append(elem);
          }
        });
        if (accumulator) {
          return yielder["yield"](accumulator);
        }
      });
    };

    Enumerable.prototype.sort = function(block) {
      return new RArray(_itr.sort(this, block));
    };

    Enumerable.prototype.sort_by = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('sort_by');
      }
      return new RArray(_itr.sort_by(this, block));
    };

    Enumerable.prototype.take = function(n) {
      __ensure_args_length(arguments, 1);
      n = RCoerce.to_int_native(n);
      if (n < 0) {
        throw R.ArgumentError["new"]();
      }
      return new RArray(_itr.take(this, n));
    };

    Enumerable.prototype.take_while = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('take_while');
      }
      return new RArray(_itr.take_while(this, block));
    };

    Enumerable.prototype.to_a = function() {
      return new RArray(_itr.to_a(this));
    };

    Enumerable.prototype.to_enum = function() {
      var args, iter;
      iter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (iter == null) {
        iter = "each";
      }
      return new R.Enumerator(this, iter, args);
    };

    Enumerable.prototype.entries = Enumerable.prototype.to_a;

    Enumerable.prototype.zip = function() {
      var block, idx, o, others, results;
      others = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = __extract_block(others);
      others = (function() {
        var _k, _len2, _results;
        _results = [];
        for (_k = 0, _len2 = others.length; _k < _len2; _k++) {
          o = others[_k];
          if (__isArr(o)) {
            _results.push(o.valueOf());
          } else {
            _results.push(o);
          }
        }
        return _results;
      })();
      results = [];
      idx = 0;
      this.each(function(el) {
        var inner, other, _k, _len2;
        inner = [el];
        for (_k = 0, _len2 = others.length; _k < _len2; _k++) {
          other = others[_k];
          el = __isArr(other) ? other[idx] : other;
          if (el === void 0) {
            el = null;
          }
          inner.push(el);
        }
        if (block) {
          block(inner);
        }
        results.push(inner);
        return idx += 1;
      });
      if (block) {
        return null;
      } else {
        return new RArray(results);
      }
    };

    Enumerable.prototype.collectConcat = Enumerable.prototype.collect_concat;

    Enumerable.prototype.dropWhile = Enumerable.prototype.drop_while;

    Enumerable.prototype.eachCons = Enumerable.prototype.each_cons;

    Enumerable.prototype.eachEntry = Enumerable.prototype.each_entry;

    Enumerable.prototype.eachSlice = Enumerable.prototype.each_slice;

    Enumerable.prototype.eachWithIndex = Enumerable.prototype.each_with_index;

    Enumerable.prototype.eachWithObject = Enumerable.prototype.each_with_object;

    Enumerable.prototype.findAll = Enumerable.prototype.find_all;

    Enumerable.prototype.findIndex = Enumerable.prototype.find_index;

    Enumerable.prototype.flatMap = Enumerable.prototype.flat_map;

    Enumerable.prototype.groupBy = Enumerable.prototype.group_by;

    Enumerable.prototype.maxBy = Enumerable.prototype.max_by;

    Enumerable.prototype.minBy = Enumerable.prototype.min_by;

    Enumerable.prototype.minmaxBy = Enumerable.prototype.minmax_by;

    Enumerable.prototype.reverseEach = Enumerable.prototype.reverse_each;

    Enumerable.prototype.sliceBefore = Enumerable.prototype.slice_before;

    Enumerable.prototype.sortBy = Enumerable.prototype.sort_by;

    Enumerable.prototype.takeWhile = Enumerable.prototype.take_while;

    Enumerable.prototype.toA = Enumerable.prototype.to_a;

    return Enumerable;

  })();

  RubyJS.Enumerable.SortedElement = (function() {
    function SortedElement(value, sort_by) {
      this.value = value;
      this.sort_by = sort_by;
    }

    SortedElement.prototype.cmp = function(other) {
      var _ref4;
      return (_ref4 = this.sort_by) != null ? _ref4.cmp(other.sort_by) : void 0;
    };

    return SortedElement;

  })();

  REnumerable = RubyJS.Enumerable;

  RubyJS.Enumerator = (function(_super) {
    __extends(Enumerator, _super);

    Enumerator.include(RubyJS.Enumerable);

    Enumerator["new"] = function() {
      var args, iter, obj;
      obj = arguments[0], iter = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return new RubyJS.Enumerator(obj, iter, args);
    };

    function Enumerator(object, iter, args) {
      this.object = object;
      this.iter = iter != null ? iter : 'each';
      this.args = args != null ? args : [];
      this.generator = null;
      this.length = this.object.length;
      this.idx = 0;
    }

    Enumerator.create = function() {
      var args, block, iter, object;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (block = __extract_block(args)) {
        object = new RubyJS.Enumerator.Generator(block);
        iter = 'each';
        return Enumerator["new"](object, iter);
      }
    };

    Enumerator.prototype.is_enumerator = function() {
      return true;
    };

    Enumerator.prototype.each = function(block) {
      var _ref4;
      return (_ref4 = this.object)[this.iter].apply(_ref4, __slice.call(this.args).concat([block]));
    };

    Enumerator.prototype.each_with_index = function(block) {
      var callback, idx;
      if (!(block && (block.call != null))) {
        return this.to_enum('each_with_index');
      }
      callback = R.blockify(block, this);
      idx = 0;
      return this.each(function() {
        var args, val;
        args = BlockMulti.prototype.args(arguments);
        val = callback.invokeSplat(args, idx);
        idx += 1;
        return val;
      });
    };

    Enumerator.prototype.size = function() {
      return this.object.length;
    };

    Enumerator.prototype.iterator = function() {
      return this.valueOf();
    };

    Enumerator.prototype.next = function() {
      var idx;
      idx = this.idx;
      this.idx += 1;
      return this.valueOf()[idx];
    };

    Enumerator.prototype.to_a = function() {
      return new RArray(this.valueOf());
    };

    Enumerator.prototype.to_enum = function() {
      var args, iter;
      iter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (iter == null) {
        iter = "each";
      }
      return new RubyJS.Enumerator(this, iter, args);
    };

    Enumerator.prototype.valueOf = function() {
      return _itr.to_a(this);
    };

    Enumerator.prototype.eachWithIndex = Enumerator.prototype.each_with_index;

    return Enumerator;

  })(RubyJS.Object);

  RubyJS.Enumerator.Yielder = (function(_super) {
    __extends(Yielder, _super);

    function Yielder(proc) {
      this.proc = proc;
      if (this.proc.call == null) {
        throw 'LocalJumpError';
      }
    }

    Yielder.prototype["yield"] = function() {
      return this.proc.apply(this, arguments);
    };

    Yielder.prototype['<<'] = function(value) {
      this["yield"](value);
      return this;
    };

    return Yielder;

  })(RubyJS.Object);

  RubyJS.Enumerator.Generator = (function(_super) {
    __extends(Generator, _super);

    function Generator(proc) {
      this.proc = proc;
      if (this.proc.call == null) {
        throw 'LocalJumpError';
      }
    }

    Generator.prototype.each = function(block) {
      var enclosed_yield;
      enclosed_yield = function() {
        return block.apply(this, arguments);
      };
      return this.proc(new RubyJS.Enumerator.Yielder(enclosed_yield));
    };

    return Generator;

  })(RubyJS.Object);

  RubyJS.Array = (function(_super) {
    __extends(Array, _super);

    Array.include(R.Enumerable);

    Array.prototype.is_array = function() {
      return true;
    };

    Array.prototype.iterator = function() {
      return this.__native__;
    };

    function Array(__native__, recursive) {
      var idx, len;
      this.__native__ = __native__ != null ? __native__ : [];
      if (recursive === true) {
        idx = -1;
        len = this.__native__.length;
        while (++idx < len) {
          this.__native__[idx] = R(this.__native__[idx], recursive);
        }
      }
    }

    Array["new"] = function() {
      var args, ary, block, idx, obj, size;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = __extract_block(args);
      if (args.length >= 3) {
        throw R.ArgumentError["new"]();
      }
      size = args[0];
      obj = args[1];
      if (size === void 0) {
        return new R.Array([]);
      }
      if (obj !== void 0 && (this.isNativeArray(size) || (size.is_array != null))) {
        throw R.TypeError["new"]();
      }
      if (this.isNativeArray(size)) {
        return new R.Array(size);
      }
      if ((size.to_ary != null) && obj === void 0) {
        return size.to_ary();
      }
      size = RCoerce.to_int_native(size);
      if (size < 0) {
        throw R.ArgumentError["new"]();
      }
      if (obj === void 0) {
        obj = null;
      }
      ary = [];
      idx = -1;
      while (++idx < size) {
        ary[idx] = block ? block(idx) : obj;
      }
      return new R.Array(ary);
    };

    Array.typecast = function(arr, recursive) {
      return new R.Array(arr, recursive);
    };

    Array.isNativeArray = nativeArray.isArray || function(obj) {
      return nativeToString.call(obj) === '[object Array]';
    };

    Array.try_convert = function(obj) {
      if (obj.is_array != null) {
        return obj;
      }
      if (this.isNativeArray(obj)) {
        return this["new"](obj);
      }
      if (obj.to_ary != null) {
        return obj.to_ary();
      } else {
        return null;
      }
    };

    Array.prototype.valueOf = function(recursive) {
      if (recursive) {
        return this.to_native(true);
      } else {
        return this.__native__;
      }
    };

    Array.prototype.to_native = function(recursive) {
      var ary, el, idx, len, _ref4;
      if (recursive == null) {
        recursive = false;
      }
      if (recursive) {
        _ref4 = this.__iter_vars__(), idx = _ref4[0], len = _ref4[1], ary = _ref4[2];
        while (++idx < len) {
          el = this.__native__[idx];
          if (el && (el.to_native != null)) {
            el = el.to_native(true);
          }
          ary[idx] = el;
        }
        return ary;
      } else {
        return this.__native__.slice(0);
      }
    };

    Array.prototype.unbox = Array.prototype.to_native;

    Array.prototype.to_native_clone = function() {
      return this.__native__.slice(0);
    };

    Array.prototype.__iter_vars__ = function(no_array) {
      var len;
      len = this.__native__.length;
      if (no_array) {
        return [-1, len];
      } else {
        return [-1, len, nativeArray(len)];
      }
    };

    Array.prototype.equals = function(other) {
      other = R(other);
      if (other.is_array == null) {
        if (other.to_ary == null) {
          return false;
        }
        return other.equals(this);
      }
      return _arr.equals(this.__native__, other.__native__);
    };

    Array.prototype['<<'] = function(obj) {
      this.__native__.push(obj);
      return this;
    };

    Array.prototype['&'] = function(other) {
      return new RArray(_arr.intersection(this.__native__, other));
    };

    Array.prototype.cmp = function(other) {
      return _arr.cmp(this.__native__, other);
    };

    Array.prototype.at = function(index) {
      index = RCoerce.to_int_native(index);
      return _arr.at(this.__native__, index);
    };

    Array.prototype.clear = function() {
      __ensure_args_length(arguments, 0);
      this.__native__.length = 0;
      this.replace(this.__native__);
      return this;
    };

    Array.prototype.clone = function() {
      return this.dup();
    };

    Array.prototype.collect_bang = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('collect_bang');
      }
      return this.replace(_arr.collect(this.__native__, block));
    };

    Array.prototype.combination = function(num, block) {
      if (block == null) {
        return this.to_enum('combination', num);
      }
      _arr.combination(this.__native__, num, block);
      return this;
    };

    Array.prototype.compact = function() {
      return new RArray(_arr.compact(this.__native__));
    };

    Array.prototype.compact_bang = function() {
      var ary, len;
      len = this.__native__.length;
      ary = _arr.compact(this.__native__);
      this.replace(ary);
      if (len === ary.length) {
        return null;
      } else {
        return this;
      }
    };

    Array.prototype.concat = function(other) {
      other = RCoerce.to_ary_native(other);
      return this.replace(this.__native__.concat(other));
    };

    Array.prototype["delete"] = function() {
      var args, block;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = __extract_block(args);
      return _arr["delete"](this.__native__, args[0], block);
    };

    Array.prototype.delete_at = function(idx) {
      idx = RCoerce.to_int_native(idx);
      return _arr.delete_at(this.__native__, idx);
    };

    Array.prototype.delete_if = function(block) {
      return this.replace(this.reject(block));
    };

    Array.prototype.dup = function() {
      return new RubyJS.Array(this.__native__.slice(0));
    };

    Array.prototype.eql = function(other) {
      var other_arr;
      if (this.equals(other)) {
        return true;
      }
      other = R(other);
      if (other.is_array == null) {
        return false;
      }
      if (!this.size().equals(other.size())) {
        return false;
      }
      other_arr = other.to_native();
      return this.catch_break(function(breaker) {
        var i;
        i = 0;
        this.each(function(x) {
          if (!R(x).eql(other_arr[i])) {
            breaker["break"](false);
          }
          return i += 1;
        });
        return true;
      });
    };

    Array.prototype.each_index = function(block) {
      if (block == null) {
        return this.to_enum('each_index');
      }
      _arr.each_index(this.__native__, block);
      return this;
    };

    Array.prototype.each = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum();
      }
      _arr.each(this.__native__, block);
      return this;
    };

    Array.prototype.get = function(a, b) {
      return this.slice(a, b);
    };

    Array.prototype.set = function(idx, obj) {
      if (idx.is_range != null) {
        return this.set$range(idx, obj);
      }
      if (arguments.length === 3) {
        return this.set$int$int.apply(this, arguments);
      }
      idx = RCoerce.to_int_native(idx);
      this.__native__[idx] = obj;
      return obj;
    };

    Array.prototype.set$range = function(rng, obj) {
      throw R.NotImplementedError["new"]();
    };

    Array.prototype.set$int$int = function(start, length, obj) {
      throw R.NotImplementedError["new"]();
    };

    Array.prototype.empty = function() {
      return this.__native__.length === 0;
    };

    Array.prototype.fetch = function(idx, default_or_block) {
      return _arr.fetch(this.__native__, idx, default_or_block);
    };

    Array.prototype.fill = function() {
      var args, block;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        throw R.ArgumentError["new"]();
      }
      block = __extract_block(args);
      if (block) {
        if (args.length >= 3) {
          throw R.ArgumentError["new"]();
        }
        _arr.fill(this.__native__, args[0], args[1], block);
      } else {
        if (args.length > 3) {
          throw R.ArgumentError["new"]();
        }
        _arr.fill(this.__native__, args[0], args[1], args[2]);
      }
      return this;
    };

    Array.prototype.flatten = function(recursion) {
      if (recursion == null) {
        recursion = -1;
      }
      return new RArray(_arr.flatten(this.__native__, recursion));
    };

    Array.prototype.insert = function(idx) {
      var ary;
      if (idx === void 0) {
        throw R.ArgumentError["new"]();
      }
      if (arguments.length === 0) {
        return this;
      }
      ary = __call(_arr.insert, this.__native__, arguments);
      return this;
    };

    Array.prototype.inspect = function() {
      return R("[" + (this.map(function(e) {
        return R.inspect(e);
      }).join(', ')) + "]");
    };

    Array.prototype.join = function(sep) {
      if (sep != null) {
        sep = RCoerce.to_str_native(sep);
      }
      return new RString(_arr.join(this.__native__, sep));
    };

    Array.prototype.keep_if = function(block) {
      var ary;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('keep_if');
      }
      ary = _arr.keep_if(this.__native__, block);
      if (this.__native__.length === ary.length) {
        return this;
      } else {
        return this.replace(ary);
      }
    };

    Array.prototype.minus = function(other) {
      return new RArray(_arr.minus(this.__native__, other));
    };

    Array.prototype.multiply = function(multiplier) {
      __ensure_args_length(arguments, 1);
      return R(_arr.multiply(this.__native__, multiplier));
    };

    Array.prototype.last = function(n) {
      if (this.__native__.length < 1) {
        if (n === void 0) {
          return null;
        }
        return new R.Array([]);
      }
      if (n === void 0) {
        return this.at(-1);
      }
      n = RCoerce.to_int_native(n);
      return new R.Array(_a.last(this.__native__, n));
    };

    Array.prototype.permutation = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      throw R.NotImplementedError["new"]();
    };

    Array.prototype.plus = function(other) {
      return this.concat(other);
    };

    Array.prototype.pop = function(many) {
      if (arguments.length > 1) {
        throw R.ArgumentError["new"]();
      }
      if (many === void 0) {
        return _arr.pop(this.__native__);
      } else {
        return new RArray(_arr.pop(this.__native__, many));
      }
    };

    Array.prototype.product = function() {
      var ary;
      ary = __call(_arr.product, this.__native__, arguments);
      if (ary === this.__native__) {
        return this;
      } else {
        return new RArray(ary);
      }
    };

    Array.prototype.push = function() {
      __call(_arr.push, this.__native__, arguments);
      return this;
    };

    Array.prototype.rassoc = function(obj) {
      return _arr.rassoc(this.__native__, obj);
    };

    Array.prototype.rindex = function(other) {
      var ridx;
      if (other === void 0) {
        return this.to_enum('rindex');
      }
      ridx = _arr.rindex(this.__native__, other);
      if (ridx === null) {
        return null;
      } else {
        return new R.Fixnum(ridx);
      }
    };

    Array.prototype.sample = function(n, range) {
      var val;
      if (range == null) {
        range = void 0;
      }
      val = _arr.sample(this.__native__, n, range);
      if (n === void 0) {
        return val;
      } else {
        return new RArray(val);
      }
    };

    Array.prototype.reject_bang = function(block) {
      var ary;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('reject_bang');
      }
      ary = this.reject(block);
      if (ary.__size__() === this.__size__()) {
        return null;
      } else {
        return this.replace(ary);
      }
    };

    Array.prototype.replace = function(val) {
      __ensure_args_length(arguments, 1);
      this.__native__ = val.to_ary != null ? val.to_ary().to_native().slice(0) : val.slice(0);
      return this;
    };

    Array.prototype.reverse = function() {
      return this.dup().tap(function(w) {
        return w.reverse_bang();
      });
    };

    Array.prototype.reverse_bang = function() {
      this.replace(this.__native__.reverse());
      return this;
    };

    Array.prototype.reverse_each = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('reverse_each');
      }
      _arr.reverse_each(this.__native__, block);
      return this;
    };

    Array.prototype.rotate = function(cnt) {
      return new RArray(_arr.rotate(this.__native__, cnt));
    };

    Array.prototype.rotate_bang = function(cnt) {
      if (cnt === 0 || cnt === 1) {
        return this;
      }
      return this.replace(_arr.rotate(this.__native__, cnt));
    };

    Array.prototype.select_bang = function(block) {
      var ary;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('select_bang');
      }
      ary = this.select(block);
      if (ary.__size__() === this.__size__()) {
        return null;
      } else {
        return this.replace(ary);
      }
    };

    Array.prototype.shift = function(n) {
      var el, ret;
      if (arguments.length > 1) {
        throw R.ArgumentError["new"]();
      }
      if (n === void 0) {
        el = this.__native__[0];
        this.replace(this.__native__.slice(1));
        return el;
      } else {
        n = RCoerce.to_int_native(n);
        if (n < 0) {
          throw R.ArgumentError["new"]();
        }
        ret = this.first(n);
        this.replace(this.__native__.slice(n));
        return ret;
      }
    };

    Array.prototype.shuffle = function() {
      return this.dup().tap(function(ary) {
        return ary.shuffle_bang();
      });
    };

    Array.prototype.shuffle_bang = function() {
      return this.replace(_arr.shuffle(this.__native__));
    };

    Array.prototype.size = function() {
      return R(this.__native__.length);
    };

    Array.prototype.__size__ = function() {
      return this.__native__.length;
    };

    Array.prototype.slice = function(idx, length) {
      var val;
      if (idx === null) {
        throw new R.TypeError["new"]();
      }
      val = _arr.slice(this.__native__, idx, length);
      if (val === null) {
        return null;
      } else if ((idx != null ? idx.is_range : void 0) != null) {
        return new RArray(val);
      } else if (length === void 0) {
        return val;
      } else {
        return new RArray(val);
      }
    };

    Array.prototype.slice_bang = function(idx, length) {
      var ary, range, rng_end, rng_length, rng_start, size;
      if (idx === null) {
        throw new R.TypeError["new"]();
      }
      ary = null;
      size = this.__size__();
      if (idx.is_range != null) {
        range = idx;
        ary = this.slice(range);
        rng_start = RCoerce.to_int_native(range.begin());
        rng_end = RCoerce.to_int_native(range.end());
        if (rng_start < 0) {
          rng_start = rng_start + size;
        }
        if (rng_end < 0) {
          rng_end = rng_end + size;
        } else if (rng_end >= size) {
          rng_end >= size;
        }
        rng_length = rng_end - rng_start;
        if (!range.exclude_end()) {
          rng_length = rng_length + 1;
        }
        if (rng_start < size && rng_start >= 0 && rng_end <= size && rng_end >= 0 && rng_length > 0) {
          this.__delete_range(rng_start, rng_length);
        }
      } else if (length !== void 0) {
        idx = RCoerce.to_int_native(idx);
        length = RCoerce.to_int_native(length);
        if (idx > size) {
          return null;
        }
        if (length === 0) {
          return new R.Array([]);
        }
        ary = this.slice(idx, length);
        this.__delete_range(idx, length);
      } else {
        idx = RCoerce.to_int_native(idx);
        ary = this.delete_at(idx);
      }
      return ary;
    };

    Array.prototype.__delete_range = function(start, length) {
      var new_ary, size;
      size = this.__size__();
      if (start > size || start < 0) {
        return null;
      }
      if (size < (start + length)) {
        new_ary = new R.Array([]);
      } else {
        new_ary = this.slice(0, start).concat(this.slice(start + length, size) || []);
      }
      if (new_ary.__size__() !== this.__size__()) {
        return this.replace(new_ary);
      }
    };

    Array.prototype.sort_bang = function(block) {
      return this.replace(this.sort(block));
    };

    Array.prototype.sort_by_bang = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('sort_by_bang');
      }
      return this.replace(this.sort_by(block));
    };

    Array.prototype.transpose = function() {
      return new RArray(_arr.transpose(this.__native__));
    };

    Array.prototype.uniq = function() {
      var arr;
      arr = new R.Array([]);
      this.each(function(el) {
        if (!arr.include(el)) {
          return arr.push(el);
        }
      });
      return arr;
    };

    Array.prototype.uniq_bang = function(block) {
      var ary;
      ary = this.uniq();
      if (ary.__size__() === this.__size__()) {
        return null;
      } else {
        return this.replace(ary);
      }
    };

    Array.prototype.unshift = function() {
      return this.replace(__call(_arr.unshift, this.__native__, arguments));
    };

    Array.prototype.union = function(other) {
      return new RArray(_arr.union(this.__native__, other));
    };

    Array.prototype.to_a = function() {
      return this.dup();
    };

    Array.prototype.to_enum = function() {
      var args, iter;
      iter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (iter == null) {
        iter = "each";
      }
      return new R.Enumerator(this, iter, args);
    };

    Array.prototype.to_ary = function() {
      return this;
    };

    Array.prototype.values_at = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new RArray(__call(_arr.values_at, this.__native__, args));
    };

    Array.__add_default_aliases__(Array.prototype);

    Array.prototype.map_bang = Array.prototype.collect_bang;

    Array.prototype.index = Array.prototype.find_index;

    Array.prototype.each_for = Array.prototype.each;

    Array.prototype['|'] = Array.prototype.union;

    Array.prototype.to_s = Array.prototype.inspect;

    Array.prototype.intersection = Array.prototype['&'];

    Array.prototype.deleteAt = Array.prototype.delete_at;

    Array.prototype.deleteIf = Array.prototype.delete_if;

    Array.prototype.dropWhile = Array.prototype.drop_while;

    Array.prototype.eachIndex = Array.prototype.each_index;

    Array.prototype.equalValue = Array.prototype.equal_value;

    Array.prototype.findIndex = Array.prototype.find_index;

    Array.prototype.intersection = Array.prototype.intersection;

    Array.prototype.keepIf = Array.prototype.keep_if;

    Array.prototype.reverse_each = Array.prototype.reverse_each;

    Array.prototype.sortBy = Array.prototype.sort_by;

    Array.prototype.takeWhile = Array.prototype.take_while;

    Array.prototype.toA = Array.prototype.to_a;

    Array.prototype.toAry = Array.prototype.to_ary;

    Array.prototype.toS = Array.prototype.to_s;

    Array.prototype.tryConvert = Array.prototype.try_convert;

    Array.prototype.valuesAt = Array.prototype.values_at;

    return Array;

  })(RubyJS.Object);

  RArray = R.Array = RubyJS.Array;

  RubyJS.Hash = (function(_super) {
    __extends(Hash, _super);

    Hash.include(R.Enumerable);

    Hash["new"] = function() {
      return new R.Hash();
    };

    function Hash(hsh, default_value) {
      this.__native__ = hsh;
      this.__default__ = default_value;
    }

    Hash.prototype.assoc = function(needle) {
      var val;
      val = _hsh.assoc(this.__native__, needle);
      if (val === null) {
        return null;
      } else {
        return new RArray(val);
      }
    };

    Hash.prototype.clear = function() {
      this.__native__ = {};
      return this;
    };

    Hash.prototype["default"] = function(key) {
      if (this.__default__) {
        if (this.__default__.call != null) {
          if (key !== void 0) {
            return this.__default__(this, key);
          }
        } else {
          return this.__default__;
        }
      } else {
        return null;
      }
    };

    Hash.prototype.default_proc = function() {
      var _ref4;
      if (((_ref4 = this.__default__) != null ? _ref4.call : void 0) != null) {
        return this.__default__;
      } else {
        return null;
      }
    };

    Hash.prototype["delete"] = function(key, block) {
      return _hsh["delete"](this.__native__, key, block);
    };

    Hash.prototype.delete_if = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('delete_if');
      }
      _hsh.delete_if(this.__native__, block);
      return this;
    };

    Hash.prototype.each = function(block) {
      if (block == null) {
        return this.to_enum('each');
      }
      _hsh.each(this.__native__, block);
      return this;
    };

    Hash.prototype.each_pair = Hash.prototype.each;

    Hash.prototype.each_key = function(block) {
      if (block == null) {
        return this.to_enum('each_key');
      }
      _hsh.each_key(this.__native__, block);
      return this;
    };

    Hash.prototype.each_value = function(block) {
      if (block == null) {
        return this.to_enum('each_value');
      }
      _hsh.each_value(this.__native__, block);
      return this;
    };

    Hash.prototype.empty = function() {
      return _hsh.empty(this.__native__);
    };

    Hash.prototype.eql = function(other) {
      var k, v, _ref4;
      other = (typeof other.to_native === "function" ? other.to_native() : void 0) || other;
      _ref4 = this.__native__;
      for (k in _ref4) {
        if (!__hasProp.call(_ref4, k)) continue;
        v = _ref4[k];
        if (k in other) {
          if (!R.is_eql(other[k], v)) {
            return false;
          }
        } else {
          return false;
        }
      }
      return true;
    };

    Hash.prototype.fetch = function(key, default_value) {
      return __call(_hsh.fetch, this.__native__, arguments);
    };

    Hash.prototype.flatten = function(recursion) {
      if (recursion == null) {
        recursion = 1;
      }
      return new RArray(_hsh.flatten(this.__native__, recursion));
    };

    Hash.prototype.get = function(key) {
      if ((this.__default__ != null) && !this.has_key(key)) {
        return this["default"](key);
      } else {
        return this.__native__[key];
      }
    };

    Hash.prototype.has_value = function(val) {
      return _hsh.has_value(this.__native__, val);
    };

    Hash.prototype.has_key = function(key) {
      return _hsh.has_key(this.__native__, key);
    };

    Hash.prototype.include = Hash.prototype.has_key;

    Hash.prototype.member = Hash.prototype.has_key;

    Hash.prototype.keep_if = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('keep_if');
      }
      _hsh.keep_if(this.__native__, block);
      return this;
    };

    Hash.prototype.key = function(value) {
      return _hsh.key(this.__native__, value);
    };

    Hash.prototype.index = Hash.prototype.key;

    Hash.prototype.invert = function() {
      return new R.Hash(_hsh.invert(this.__native__));
    };

    Hash.prototype.keys = function() {
      return new R.Array(_hsh.keys(this.__native__));
    };

    Hash.prototype.merge = function(other, block) {
      return new R.Hash(_hsh.merge(this.__native__, other, block));
    };

    Hash.prototype.merge_bang = function(other, block) {
      _hsh.merge$(this.__native__, other, block);
      return this;
    };

    Hash.prototype.rassoc = function(needle) {
      var val;
      val = _hsh.rassoc(this.__native__, needle);
      if (val === null) {
        return null;
      } else {
        return new RArray(val);
      }
    };

    Hash.prototype.reject = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('reject');
      }
      return new R.Hash(_hsh.reject(this.__native__, block));
    };

    Hash.prototype.reject_bang = function(block) {
      var val;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('reject_bang');
      }
      val = _hsh.reject$(this.__native__, block);
      if (changed === null) {
        return null;
      } else {
        return this;
      }
    };

    Hash.prototype.select = function(block) {
      var dup;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('select');
      }
      dup = _hsh.select(this.__native__, block);
      return new R.Hash(dup);
    };

    Hash.prototype.select_bang = function(block) {
      var val;
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('select_bang');
      }
      val = _hsh.select$(this.__native__, block);
      if (val === null) {
        return null;
      } else {
        return this;
      }
    };

    Hash.prototype.set = function(key, value) {
      return this.__native__[key] = value;
    };

    Hash.prototype.sort = function(block) {
      return new RArray(_hsh.sort(this.__native__, block));
    };

    Hash.prototype.store = Hash.prototype.set;

    Hash.prototype.size = function() {
      return new R.Fixnum(_hsh.size(this.__native__));
    };

    Hash.prototype.to_a = function() {
      return new R.Array(_hsh.to_a(this.__native__));
    };

    Hash.prototype.to_hash = function() {
      return this;
    };

    Hash.prototype.to_h = Hash.prototype.to_hash;

    Hash.prototype.to_native = function() {
      return this.__native__;
    };

    Hash.prototype.update = Hash.prototype.merge_bang;

    Hash.prototype.values = function() {
      return new RArray(_hsh.values(this.__native__));
    };

    Hash.prototype.values_at = function() {
      var arr;
      arr = __call(_hsh.values_at, this.__native__, arguments);
      return new RArray(arr);
    };

    Hash.prototype.valueOf = function() {
      return this.__native__;
    };

    return Hash;

  })(RubyJS.Object);

  RHash = R.Hash;

  R.hashify = function(obj, default_value) {
    return new R.Hash(obj, default_value);
  };

  R.h = R.hashify;

  RubyJS.Range = (function(_super) {
    __extends(Range, _super);

    Range.include(R.Enumerable);

    Range["new"] = function(start, end, exclusive) {
      if (exclusive == null) {
        exclusive = false;
      }
      return new R.Range(start, end, exclusive);
    };

    function Range(start, end, exclusive) {
      var err;
      this.exclusive = exclusive != null ? exclusive : false;
      this.__start__ = this.box(start);
      this.__end__ = this.box(end);
      if (!((this.__start__.is_fixnum != null) && (this.__end__.is_fixnum != null))) {
        try {
          if (this.__start__.cmp(this.__end__) === null) {
            throw R.ArgumentError["new"]();
          }
        } catch (_error) {
          err = _error;
          throw R.ArgumentError["new"]();
        }
      }
      this.comparison = this.exclusive ? 'lt' : 'lteq';
    }

    Range.prototype.is_range = function() {
      return true;
    };

    Range.prototype.iterator = function() {
      var arr;
      arr = [];
      this.each(function(e) {
        return arr.push(e);
      });
      return arr;
    };

    Range.prototype.equals = function(other) {
      if (!(other instanceof R.Range)) {
        return false;
      }
      return this.__end__.equals(other.end()) && this.__start__.equals(other.start()) && this.exclusive === other.exclude_end();
    };

    Range.prototype.begin = function(obj) {
      return this.__start__;
    };

    Range.prototype.cover = function(obj) {
      if (arguments.length !== 1) {
        throw R.ArgumentError["new"]();
      }
      obj = obj;
      if (obj === null) {
        return false;
      }
      return this.equal_case(obj);
    };

    Range.prototype['==='] = function(other) {
      var e, s;
      other = R(other);
      s = other.cmp(this.__start__);
      e = other.cmp(this.__end__);
      if (s === null && e === null) {
        return false;
      }
      s = -s;
      e = -e;
      return s <= 0 && (this.exclusive ? e > 0 : e >= 0);
    };

    Range.prototype.each = function(block) {
      var iterator;
      if (!(block && (block.call != null))) {
        return this.to_enum('each');
      }
      if (this.begin().succ == null) {
        throw R.TypeError["new"]("can't iterate from " + (this.begin()));
      }
      iterator = this.__start__.dup();
      while (iterator[this.comparison](this.__end__)) {
        block(iterator.valueOf());
        iterator = iterator.succ();
      }
      return this;
    };

    Range.prototype.end = function() {
      return this.__end__;
    };

    Range.prototype.exclude_end = function() {
      return this.exclusive;
    };

    Range.prototype.first = function(n) {
      return this.begin();
    };

    Range.prototype.inspect = function() {
      var sep;
      sep = this.exclude_end() ? "..." : "..";
      return "" + (this.start().inspect()) + sep + (this.end().inspect());
    };

    Range.prototype.min = function(block) {
      var b, e;
      if ((block != null ? block.call : void 0) != null) {
        return R.Enumerable.prototype.min.call(this, block);
      }
      b = this.begin();
      e = this.end();
      if (e['lt'](b) || (this.exclusive && e.equals(b))) {
        return null;
      }
      if (b.is_float != null) {
        return b.valueOf();
      }
      return R.Enumerable.prototype.min.call(this);
    };

    Range.prototype.max = function(block) {
      var b, e;
      if ((block != null ? block.call : void 0) != null) {
        return R.Enumerable.prototype.max.call(this, block);
      }
      b = this.begin();
      e = this.end();
      if (e['lt'](b) || (this.exclusive && e.equals(b))) {
        return null;
      }
      if ((e.is_float != null) || ((e.is_float != null) && !this.exclusive)) {
        return e.valueOf();
      }
      return R.Enumerable.prototype.max.call(this);
    };

    Range.prototype.start = function() {
      return this.__start__;
    };

    Range.prototype.step = function(step_size, block) {
      var cmp, cnt, first, last;
      if (step_size == null) {
        step_size = 1;
      }
      if (arguments.length === 1 && (step_size.call != null)) {
        block = step_size;
        step_size = 1;
      }
      if (!(block && (block.call != null))) {
        return this.to_enum('step', step_size);
      }
      step_size = R(step_size);
      first = this.begin();
      last = this.end();
      if (((step_size != null ? step_size.is_float : void 0) != null) || (first.is_float != null) || (last.is_float != null)) {
        step_size = step_size.to_f();
        first = first.to_f();
        last = last.to_f();
      } else {
        step_size = RCoerce.to_int_native(step_size);
      }
      if (step_size <= 0) {
        if (step_size < 0) {
          throw R.ArgumentError["new"]();
        }
        throw R.ArgumentError["new"]();
      }
      cnt = first;
      cmp = this.exclude_end() ? 'lt' : 'lteq';
      if (first.is_float != null) {
        while (cnt[cmp](last)) {
          block(cnt.valueOf());
          cnt = cnt.plus(step_size);
        }
      } else if (first.is_fixnum != null) {
        while (cnt[cmp](last)) {
          block(cnt.valueOf());
          cnt = cnt.plus(step_size);
        }
      } else {
        cnt = 0;
        this.each(function(o) {
          if (cnt % step_size === 0) {
            block(o);
          }
          return cnt += 1;
        });
      }
      return this;
    };

    Range.prototype.to_a = function() {
      if ((this.__end__.is_float != null) && (this.__start__.is_float != null)) {
        throw R.TypeError["new"]();
      }
      return R.Enumerable.prototype.to_a.apply(this);
    };

    Range.prototype.to_s = Range.prototype.inspect;

    Range.__add_default_aliases__(Range.prototype);

    Range.prototype.eql = Range.prototype.equals;

    Range.prototype.include = Range.prototype['==='];

    Range.prototype.last = Range.prototype.end;

    Range.prototype.member = Range.prototype.include;

    Range.prototype.excludeEnd = Range.prototype.exclude_end;

    return Range;

  })(RubyJS.Object);

  RubyJS.MatchData = (function(_super) {
    __extends(MatchData, _super);

    function MatchData(__native__, opts) {
      var i, m, _k, _len2, _ref4;
      this.__native__ = __native__;
      if (opts == null) {
        opts = {};
      }
      _ref4 = this.__native__;
      for (i = _k = 0, _len2 = _ref4.length; _k < _len2; i = ++_k) {
        m = _ref4[i];
        this[i] = m;
      }
      this.__offset__ = opts.offset || 0;
      this.__source__ = opts.string;
      this.__regexp__ = opts.regexp;
    }

    MatchData.prototype.is_match_data = function() {
      return true;
    };

    MatchData.prototype.equals = function(other) {
      if (other.is_match_data == null) {
        return false;
      }
      return this.regexp().equals(other.regexp()) && this.string().equals(other.string()) && this.__offset__ === other.__offset__;
    };

    MatchData.prototype.begin = function(offset) {
      __ensure_args_length(1);
      return R(this.__source__.slice(this.__offset__).indexOf(this.__native__[offset]) + this.__offset__);
    };

    MatchData.prototype.captures = function() {
      return R(this.__native__.slice(1));
    };

    MatchData.prototype.end = function(offset) {
      __ensure_args_length(1);
      return R(this.__source__.slice(this.__offset__).indexOf(this.__native__[offset]) + this.__offset__ + this.__native__[offset].length);
    };

    MatchData.prototype.eql = function(other) {
      return this.equals(other);
    };

    MatchData.prototype.get = function() {
      var args, arr;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      arr = this.to_a();
      return arr.get.apply(arr, arguments);
    };

    MatchData.prototype.inspect = function() {
      var results;
      results = R(["\"" + this[0] + "\""]);
      results.concat(this.captures().each_with_index().map(function(w, i) {
        return "" + (i + 1) + ":\"" + w + "\"";
      }));
      return new R.String("#<MatchData " + (results.join(" ")) + ">");
    };

    MatchData.prototype.length = function() {
      return R(this.__native__.length);
    };

    MatchData.prototype.offset = function(offset) {
      var b;
      b = this.begin(offset);
      return R([b.to_native(), b + this.__native__[offset].length]);
    };

    MatchData.prototype.post_match = function() {
      return this.__source__.slice(this.end(0));
    };

    MatchData.prototype.pre_match = function() {
      return this.__source__.slice(0, this.begin(0));
    };

    MatchData.prototype.regexp = function() {
      return R(this.__regexp__);
    };

    MatchData.prototype.size = function() {
      return this.length();
    };

    MatchData.prototype.string = function() {
      return R(this.__source__);
    };

    MatchData.prototype.to_a = function() {
      return R(this.__native__);
    };

    MatchData.prototype.to_s = function() {
      return R(this.__native__[0]);
    };

    MatchData.prototype.values_at = function() {
      var arr, indices;
      indices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      arr = this.to_a();
      return arr.values_at.apply(arr, indices);
    };

    MatchData.prototype.names = function() {
      throw R.NotSupportedError["new"]();
    };

    MatchData.prototype.postMatch = MatchData.prototype.post_match;

    MatchData.prototype.preMatch = MatchData.prototype.pre_match;

    MatchData.prototype.valuesAt = MatchData.prototype.values_at;

    return MatchData;

  })(RubyJS.Object);

  nativeString = root.String;

  RubyJS.String = (function(_super) {
    __extends(String, _super);

    String.include(R.Comparable);

    String.fromCharCode = function(obj) {
      return nativeString.fromCharCode(obj);
    };

    String["new"] = function(str) {
      if (str == null) {
        str = '';
      }
      return new R.String(str);
    };

    function String(primitive) {
      if (primitive == null) {
        primitive = "";
      }
      if (typeof primitive !== 'string') {
        primitive = primitive.valueOf();
      }
      this.replace(primitive);
    }

    String.isString = function(obj) {
      if (obj == null) {
        return false;
      }
      if (typeof obj === 'string') {
        return true;
      }
      if (typeof obj !== 'object') {
        return false;
      }
      if (obj.is_string != null) {
        return true;
      }
      return nativeToString.call(obj) === '[object String]';
    };

    String.try_convert = function(obj) {
      if (!(this.isString(obj) || (obj.to_str != null))) {
        return null;
      }
      if (obj.to_str != null) {
        obj = obj.to_str();
        if (obj === null || obj === void 0) {
          return null;
        }
        if (obj.is_string == null) {
          throw R.TypeError["new"]();
        }
        return obj;
      } else {
        return this["new"](obj);
      }
    };

    String.prototype.is_string = function() {
      return true;
    };

    String.prototype.to_native = function() {
      return this.__native__;
    };

    String.prototype.valueOf = function() {
      return this.__native__;
    };

    String.prototype.toString = function() {
      return this.to_native();
    };

    String.prototype.unbox = function() {
      return this.__native__;
    };

    String.prototype.initialize_copy = function() {};

    String.prototype.clone = function() {
      return new this.constructor(this.to_native() + "");
    };

    String.prototype['%'] = function(num) {
      throw R.NotImplementedError["new"]();
    };

    String.prototype['*'] = function(num) {
      num = RCoerce.to_int_native(num);
      return new RString(_str.multiply(this.__native__, num));
    };

    String.prototype.plus = function(other) {
      other = RCoerce.to_str_native(other);
      return new R.String(this.to_native() + other);
    };

    String.prototype.cmp = function(other) {
      other = R(other);
      if (other.to_str == null) {
        return null;
      }
      if (other.cmp == null) {
        return null;
      }
      if (other.is_string != null) {
        other = other.to_native();
        if (this.to_native() === other) {
          return 0;
        } else if (this.to_native() < other) {
          return -1;
        } else {
          return 1;
        }
      } else {
        return -other.cmp(this);
      }
    };

    String.prototype.equals = function(other) {
      if (other.is_string != null) {
        return this.to_native() === other.to_native();
      } else if (String.isString(other)) {
        return this.to_native() === other;
      } else if (other.to_str != null) {
        return other.equals(this.to_native());
      } else {
        return false;
      }
    };

    String.prototype['<<'] = function(other) {
      other = this.box(other);
      if (other.is_integer != null) {
        if (other.lt(0)) {
          throw new Error("RangeError");
        }
        other = other.chr();
      }
      if ((other != null ? other.to_str : void 0) == null) {
        throw R.TypeError["new"]();
      }
      return this.replace(this.to_native() + other.to_str().to_native());
    };

    String.prototype['=~'] = function(pattern, offset, block) {
      if (R(pattern).is_string != null) {
        throw R.TypeError["new"]();
      }
      return this.match(pattern, offset, block);
    };

    String.prototype.capitalize = function() {
      return new RString(_str.capitalize(this.__native__));
    };

    String.prototype.capitalize_bang = function() {
      var str;
      str = _str.capitalize(this.__native__);
      if (this.__native__ === str) {
        return null;
      } else {
        return this.replace(str);
      }
    };

    String.prototype.casecmp = function(other) {
      var _base;
      other = typeof (_base = R(other)).to_str === "function" ? _base.to_str() : void 0;
      if (!other) {
        throw R.TypeError["new"]();
      }
      return this.downcase().cmp(other.downcase());
    };

    String.prototype.center = function(length, padString) {
      if (padString == null) {
        padString = ' ';
      }
      length = RCoerce.to_int_native(length);
      padString = RCoerce.to_str_native(padString);
      return new RString(_str.center(this.__native__, length, padString));
    };

    String.prototype.chars = function(block) {
      if (!(block && (block.call != null))) {
        return this.to_enum('chars');
      }
      _str.chars(this.__native__, block);
      return this;
    };

    String.prototype.chomp = function(sep) {
      if (sep == null) {
        sep = null;
      }
      if (sep === null) {
        return this;
      } else {
        return new RString(_str.chomp(this.__native__, sep));
      }
    };

    String.prototype.chomp_bang = function(sep) {
      var str;
      if (sep == null) {
        sep = null;
      }
      if (str = _str.chomp(this.__native__, sep)) {
        return this.replace(str);
      } else {
        return null;
      }
    };

    String.prototype.chop = function() {
      return new RString(_str.chop(this.__native__));
    };

    String.prototype.chr = function() {
      return new RString(this.__native__[0] || '');
    };

    String.prototype.clear = function() {
      return this.replace("");
    };

    String.prototype.count = function() {
      var num;
      num = __call(_str.count, this.__native__, arguments);
      return new R.Fixnum(num);
    };

    String.prototype["delete"] = function() {
      var args;
      args = arguments;
      return this.dup().tap(function(s) {
        return s.delete_bang.apply(s, args);
      });
    };

    String.prototype.delete_bang = function() {
      var args, el, i, str, _k, _len2;
      args = [this.__native__];
      for (i = _k = 0, _len2 = arguments.length; _k < _len2; i = ++_k) {
        el = arguments[i];
        args[i + 1] = RCoerce.to_str_native(el);
      }
      str = _str["delete"].apply(null, args);
      if (this.__native__ === str) {
        return null;
      } else {
        return this.replace(str);
      }
    };

    String.prototype.downcase = function() {
      return new RString(_str.downcase(this.__native__));
    };

    String.prototype.downcase_bang = function() {
      if (!this.__native__.match(/[A-Z]/)) {
        return null;
      }
      return this.replace(_str.downcase(this.__native__));
    };

    String.prototype.dump = function() {
      return new RString(_str.dump(this.__native__));
    };

    String.prototype.dup = function() {
      var dup;
      dup = this.clone();
      dup.initialize_copy(this);
      return dup;
    };

    String.prototype.each_char = String.prototype.chars;

    String.prototype.each_line = function() {
      var args, block, dup, lft, remainder, rgt, separator, str;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      block = __extract_block(args);
      if (!(block && (block.call != null))) {
        return this.to_enum('lines', args[0]);
      }
      if (args[0] === null) {
        block(this);
        return;
      }
      separator = R(args[0] === void 0 ? R['$/'] : args[0]);
      if (separator.to_str == null) {
        throw R.TypeError["new"]();
      }
      separator = separator.to_str();
      if (separator.length === 0) {
        separator = "\n\n";
      }
      lft = 0;
      rgt = null;
      dup = this.dup();
      while (rgt = dup.index(separator, lft)) {
        rgt = rgt.succ();
        str = dup.slice(lft, rgt.minus(lft));
        lft = rgt;
        block(str.valueOf());
      }
      if (remainder = dup.to_native().slice(lft.to_native())) {
        if (remainder.length !== 0) {
          block(remainder);
        }
      }
      return this;
    };

    String.prototype.empty = function() {
      return _str.empty(this.__native__);
    };

    String.prototype.end_with = function() {
      return __call(_str.end_with, this.__native__, arguments);
    };

    String.prototype.eql = function(other) {
      return this.cmp(other) === 0;
    };

    String.prototype.get = function() {
      return this.slice.apply(this, arguments);
    };

    String.prototype.set = function(idx, other) {
      var chrs, index;
      idx = R(idx);
      other = RCoerce.to_str(other);
      index = null;
      if (idx.to_int != null) {
        index = idx.to_int().to_native();
        if (index < 0) {
          index += this.length;
        }
        if (index < 0 || index > this.length) {
          throw R.IndexError["new"]();
        }
      } else if (idx.to_str != null) {
        index = this.index(idx);
        if (!index) {
          throw R.IndexError["new"]();
        }
      }
      chrs = this.to_native().split("");
      chrs[index] = other;
      this.replace(chrs.join(''));
      return other;
    };

    String.prototype.gsub = function(pattern, replacement) {
      var gsubbed;
      if (pattern === null) {
        throw R.TypeError["new"]();
      }
      replacement = RCoerce.to_str_native(replacement);
      gsubbed = _str.gsub(this.__native__, pattern, replacement);
      return new RString(gsubbed);
    };

    String.prototype.include = function(other) {
      other = RCoerce.to_str_native(other);
      return _str.include(this.__native__, other);
    };

    String.prototype.index = function(needle, offset) {
      var val;
      val = _str.index(this.__native__, needle, offset);
      if (val === null) {
        return null;
      } else {
        return new R.Fixnum(val);
      }
    };

    String.prototype.insert = function(idx, other) {
      idx = RCoerce.to_int_native(idx);
      other = RCoerce.to_str_native(other);
      return this.replace(_str.insert(this.__native__, idx, other));
    };

    String.prototype.inspect = function() {
      return this.dump();
    };

    String.prototype.lines = String.prototype.each_line;

    String.prototype.ljust = function(width, padString) {
      if (padString == null) {
        padString = " ";
      }
      width = RCoerce.to_int_native(width);
      padString = RCoerce.to_str_native(padString);
      return new RString(_str.ljust(this.__native__, width, padString));
    };

    String.prototype.lstrip = function() {
      return new RString(_str.lstrip(this.__native__));
    };

    String.prototype.lstrip_bang = function() {
      if (!this.to_native().match(/^[\s\n\t]+/)) {
        return null;
      }
      return this.replace(_str.lstrip(this.__native__));
    };

    String.prototype.match = function(pattern, offset, block) {
      return _str.match(this.__native__, pattern, offset, block);
    };

    String.prototype.partition = function(pattern) {
      pattern = RCoerce.to_str_native(pattern);
      return new RArray(_str.partition(this.__native__, pattern));
    };

    String.prototype.prepend = function(other) {
      other = RCoerce.to_str_native(other);
      return this.replace(other + this.__native__);
    };

    String.prototype.replace = function(val) {
      if (typeof val !== 'string') {
        val = R(val);
        if (val.to_str == null) {
          throw R.TypeError["new"]();
        }
        val = val.to_str().valueOf();
      }
      this.__native__ = val;
      this.length = val.length;
      return this;
    };

    String.prototype.reverse = function() {
      return new RString(_str.reverse(this.__native__));
    };

    String.prototype.reverse_bang = function() {
      return this.replace(_str.reverse(this.__native__));
    };

    String.prototype.rindex = function(needle, offset) {
      var val, _ref4;
      if (offset === null) {
        throw R.TypeError["new"]('TypeError');
      }
      needle = R(needle);
      if (needle.to_str != null) {
        needle = needle.to_str();
      } else if (needle.is_regexp != null) {
        needle = needle;
      } else {
        throw R.TypeError["new"]('TypeError');
      }
      offset = (_ref4 = R(offset)) != null ? _ref4.to_int().valueOf() : void 0;
      needle = needle.valueOf();
      val = _str.rindex(this.__native__, needle, offset);
      if (val === null) {
        return null;
      } else {
        return new R.Fixnum(val);
      }
    };

    String.prototype.rjust = function(width, padString) {
      if (padString == null) {
        padString = " ";
      }
      return new RString(_str.rjust(this.__native__, width, padString));
    };

    String.prototype.rpartition = function(pattern) {
      return new RArray(_str.rpartition(this.__native__, pattern));
    };

    String.prototype.rstrip = function() {
      return this.dup().tap(function(s) {
        return s.rstrip_bang();
      });
    };

    String.prototype.rstrip_bang = function() {
      if (!this.__native__.match(/[\s\n\t]+$/)) {
        return null;
      }
      return this.replace(_str.rstrip(this.__native__));
    };

    String.prototype.scan = function(pattern, block) {
      var match_arr;
      if (block == null) {
        block = null;
      }
      match_arr = _str.scan(this.__native__, pattern, block);
      if (block !== null) {
        return this;
      } else {
        return new RArray(match_arr);
      }
    };

    String.prototype.size = function() {
      return this.$Integer(this.to_native().length);
    };

    String.prototype.slice = function(index, other) {
      var val;
      if (index === null) {
        throw R.TypeError["new"]();
      }
      index = R(index);
      if (other !== void 0) {
        if (index.is_regexp != null) {
          throw R.NotImplementedError["new"]();
        } else {
          index = RCoerce.to_int_native(index);
          other = RCoerce.to_int_native(other);
          val = _str.slice(this.__native__, index, other);
          if (val != null) {
            return new RString(val);
          } else {
            return null;
          }
        }
      }
      if (index.is_regexp != null) {
        throw R.NotImplementedError["new"]();
      } else if (index.is_string != null) {
        index = RCoerce.to_str_native(index);
      } else if (index.is_range != null) {

      } else {
        index = RCoerce.to_int_native(index);
      }
      val = _str.slice(this.__native__, index);
      if (val != null) {
        return new RString(val);
      } else {
        return null;
      }
    };

    String.prototype.split = function(pattern, limit) {
      if (pattern == null) {
        pattern = " ";
      }
      if (!R.Regexp.isRegexp(pattern)) {
        pattern = RCoerce.to_str_native(pattern);
      }
      return new RArray(_str.split(this.__native__, pattern, limit));
    };

    String.prototype.squeeze_bang = function() {
      throw new R.NotImplementedError();
    };

    String.prototype.squeeze = function() {
      var args, el, i, _k, _len2;
      args = [this.__native__];
      for (i = _k = 0, _len2 = arguments.length; _k < _len2; i = ++_k) {
        el = arguments[i];
        args.push(__str(el));
      }
      return new RString(_str.squeeze.apply(_str, args));
    };

    String.prototype.start_with = function() {
      return __call(_str.start_with, this.__native__, arguments);
    };

    String.prototype.strip = function() {
      return this.dup().tap(function(s) {
        return s.strip_bang();
      });
    };

    String.prototype.strip_bang = function() {
      var str;
      str = _str.strip(this.__native__);
      if (str === this.__native__) {
        return null;
      } else {
        return this.replace(str);
      }
    };

    String.prototype.sub = function(pattern, replacement) {
      return this.dup().tap(function(dup) {
        return dup.sub_bang(pattern, replacement);
      });
    };

    String.prototype.sub_bang = function(pattern, replacement) {
      if (pattern === null) {
        throw R.TypeError["new"]();
      }
      replacement = RCoerce.to_str_native(replacement);
      return this.replace(_str.sub(this.__native__, pattern, replacement));
    };

    String.prototype.succ = function() {
      return new RString(_str.succ(this.__native__));
    };

    String.prototype.succ_bang = function() {
      var str;
      str = _str.succ(this.__native__);
      return this.replace(str);
    };

    String.prototype.next = String.prototype.succ;

    String.prototype.next_bang = String.prototype.succ_bang;

    String.prototype.swapcase = function() {
      return this.dup().tap(function(s) {
        return s.swapcase_bang();
      });
    };

    String.prototype.swapcase_bang = function() {
      if (!this.__native__.match(/[a-zA-Z]/)) {
        return null;
      }
      return this.replace(_str.swapcase(this.__native__));
    };

    String.prototype.valid_float = function() {
      var number_match;
      number_match = this.to_native().match(/^([\+\-]?\d[_\d]*)(\.\d*)?([eE][\+\-]?[\d_]+)?$/);
      return (number_match != null ? number_match[0] : void 0) != null;
    };

    String.prototype.to_f = function() {
      return this.$Float(_str.to_f(this.__native__));
    };

    String.prototype.to_i = function(base) {
      return new R.Fixnum(_str.to_i(this.__native__, base));
    };

    String.prototype.to_s = function() {
      return this;
    };

    String.prototype.to_str = String.prototype.to_s;

    String.prototype.tr = function(from_str, to_str) {
      return this.dup().tap(function(s) {
        return s.tr_bang(from_str, to_str);
      });
    };

    String.prototype.tr_bang = function(from_str, to_str) {
      throw R.NotImplementedError["new"]();
    };

    String.prototype.tr_s = function() {
      throw R.NotImplementedError["new"]();
    };

    String.prototype.upcase = function() {
      return new RString(_str.upcase(this.__native__));
    };

    String.prototype.upcase_bang = function() {
      if (!this.__native__.match(/[a-z]/)) {
        return null;
      }
      return this.replace(_str.upcase(this.__native__));
    };

    String.prototype.upto = function(stop, exclusive, block) {
      if (block === void 0 && ((exclusive != null ? exclusive.call : void 0) != null)) {
        block = exclusive;
        exclusive = false;
      }
      if (!(block && (block.call != null))) {
        return R.Enumerator["new"](this, 'upto', stop, exclusive);
      }
      _str.upto(this.__native__, stop, exclusive, block);
      return this;
    };

    String.__add_default_aliases__(String.prototype);

    String.prototype.concat = String.prototype['<<'];

    return String;

  })(RubyJS.Object);

  RString = RubyJS.String;

  RubyJS.Regexp = (function(_super) {
    __extends(Regexp, _super);

    Regexp.prototype.IGNORECASE = 1;

    Regexp.prototype.EXTENDED = 2;

    Regexp.prototype.MULTILINE = 4;

    function Regexp(__native__) {
      this.__native__ = __native__;
    }

    Regexp["new"] = function(arg) {
      if (typeof arg === 'string') {
        arg = this.__compile__(arg);
      } else if (R.Regexp.isRegexp(arg)) {

      } else if (arg.is_regexp != null) {
        arg = arg.to_native();
      } else {
        arg = this.__compile__(RCoerce.to_str_native(arg));
      }
      return new R.Regexp(arg);
    };

    Regexp.compile = Regexp["new"];

    Regexp.try_convert = function(obj) {
      if (obj === null) {
        return null;
      } else if (this.isRegexp(obj)) {
        return new R.Regexp(obj);
      } else if (obj.to_regexp != null) {
        return obj.to_regexp();
      } else {
        return null;
      }
    };

    Regexp.isRegexp = function(obj) {
      return ((obj != null ? obj.is_regexp : void 0) != null) || nativeToString.call(obj) === '[object RegExp]';
    };

    Regexp.prototype.is_regexp = function() {
      return true;
    };

    Regexp.prototype.to_native = function() {
      return this.__native__;
    };

    Regexp.prototype.inspect = function() {
      var src;
      src = this.source().to_native();
      return R("/" + src + "/" + (this.__flags__()));
    };

    Regexp.prototype.equals = function(other) {
      other = R(other);
      return (other.to_native().source === this.to_native().source) && (other.casefold() === this.casefold());
    };

    Regexp.prototype['==='] = function(other) {
      return this.match(other) !== null;
    };

    Regexp.prototype['=~'] = function(str, offset) {
      var matches;
      matches = this.match(str, offset);
      return matches != null ? matches.begin(0) : void 0;
    };

    Regexp.prototype.casefold = function() {
      return this.to_native().ignoreCase;
    };

    Regexp.prototype.encoding = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.prototype.eql = function() {
      return this.equals.apply(this, arguments);
    };

    Regexp.prototype.fixed_encoding = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.prototype.hash = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.prototype.match = function(str, offset) {
      var block, matches, opts, result;
      block = __extract_block(nativeSlice.call(arguments));
      if (str === null) {
        R['$~'] = null;
      } else {
        str = RCoerce.to_str_native(str);
        opts = {
          string: str,
          regexp: this
        };
        if (offset) {
          opts.offset = offset;
          str = str.slice(offset);
        }
        if (matches = str.match(this.to_native())) {
          R['$~'] = new R.MatchData(matches, opts);
        } else {
          R['$~'] = null;
        }
      }
      result = R['$~'];
      if (block) {
        if (result) {
          return block(result);
        } else {
          return new R.Array([]);
        }
      } else {
        return result;
      }
    };

    Regexp.prototype.quote = function(pattern) {
      return R.Regexp.quote(pattern);
    };

    Regexp.prototype.source = function() {
      return R(this.to_native().source);
    };

    Regexp.prototype.to_s = function() {
      return R("(" + (this.source()) + ")");
    };

    Regexp.prototype.valueOf = function() {
      return this.__native__;
    };

    Regexp.last_match = function(n) {
      if (n && R['$~']) {
        return R['$~'][n];
      } else {
        return R['$~'];
      }
    };

    Regexp.quote = function(pattern) {
      return this.escape(pattern);
    };

    Regexp.escape = function(pattern) {
      pattern = pattern + '';
      return pattern.replace(/([.?*+^$[\](){}|-])/g, "\\$1").replace(/[\f]/g, '\\f').replace(/[\n]/g, '\\n').replace(/[\r]/g, '\\r').replace(/[\t]/g, '\\t').replace(/[\s]/g, '\\ ');
    };

    Regexp.union = function() {
      var arg, args, first_arg, sources;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        return R(/(?!)/);
      }
      first_arg = R(args[0]);
      if ((first_arg.is_array != null) && args.length === 1) {
        args = first_arg;
      }
      sources = (function() {
        var _k, _len2, _results;
        _results = [];
        for (_k = 0, _len2 = args.length; _k < _len2; _k++) {
          arg = args[_k];
          arg = R(arg);
          if (arg.is_regexp != null) {
            _results.push(arg.to_s());
          } else {
            _results.push(RCoerce.to_str(arg));
          }
        }
        return _results;
      })();
      return new R.Regexp(new nativeRegExp(sources.join('|')));
    };

    Regexp.__compile__ = function(arg) {
      try {
        return new nativeRegExp(arg);
      } catch (_error) {
        error = _error;
        throw R.RegexpError["new"]();
      }
    };

    Regexp.prototype.__flags__ = function() {
      if (this.casefold()) {
        return 'i';
      } else {
        return '';
      }
    };

    Regexp.prototype.names = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.prototype.named_captures = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.prototype.options = function() {
      throw R.NotSupportedError["new"]();
    };

    Regexp.__add_default_aliases__(Regexp.prototype);

    Regexp.prototype.fixedEncoding = Regexp.prototype.fixed_encoding;

    return Regexp;

  })(RubyJS.Object);

  RubyJS.Numeric = (function(_super) {
    __extends(Numeric, _super);

    function Numeric() {
      _ref4 = Numeric.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    Numeric.isNumeric = function(obj) {
      if (typeof obj === 'number') {
        return true;
      }
      if (typeof obj !== 'object') {
        return false;
      }
      if (obj === null) {
        return false;
      }
      return (obj.valueOf != null) && typeof obj.valueOf() === 'number';
    };

    Numeric.try_convert = function(obj) {
      if (!this.isNumeric(obj)) {
        return null;
      }
      return this["new"](obj);
    };

    Numeric["new"] = function(value) {
      if (value % 1 === 0) {
        return new R.Fixnum(value);
      } else {
        return new R.Float(value);
      }
    };

    Numeric.typecast = function(value) {
      if (value % 1 === 0) {
        return new R.Fixnum(value);
      } else {
        return new R.Float(value);
      }
    };

    Numeric.prototype.is_numeric = function() {
      return true;
    };

    Numeric.prototype.cmp = function(other) {
      if (this === other) {
        return 0;
      } else {
        return null;
      }
    };

    Numeric.prototype.abs = function() {
      if (this.lt(0)) {
        return this.uminus();
      } else {
        return this;
      }
    };

    Numeric.prototype.abs2 = function() {
      if (typeof this.nan === "function" ? this.nan() : void 0) {
        return this;
      }
      return this.abs()['**'](2);
    };

    Numeric.prototype.ceil = function() {
      return this.to_f().ceil();
    };

    Numeric.prototype.coerce = function(other) {
      if ((other == null) || other === false) {
        throw RubyJS.TypeError["new"]();
      }
      other = R(other);
      if (other.is_string != null) {
        return this.$Array([this.$Float(other), this.to_f()]);
      } else if (other.constructor.prototype === this.constructor.prototype) {
        return this.$Array([other, this]);
      } else if (other.is_float != null) {
        return this.$Array([other, this.to_f()]);
      } else if (other.is_fixnum != null) {
        return this.$Array([other, this]);
      } else if (other.is_numeric != null) {
        return this.$Array([other.to_f(), this.to_f()]);
      } else {
        throw RubyJS.TypeError["new"]();
      }
    };

    Numeric.prototype.div = function(other) {
      other = this.box(other);
      if (other.to_int == null) {
        throw RubyJS.TypeError["new"]();
      }
      if (other.zero()) {
        throw new Error("ZeroDivisionError");
      }
      return this.divide(other).floor();
    };

    Numeric.prototype.divmod = function(other) {
      var modulus, quotient;
      quotient = this.div(other).floor();
      modulus = this.minus(quotient.multiply(other));
      return new RArray([quotient.valueOf(), modulus.valueOf()]);
    };

    Numeric.prototype.eql = function(other) {
      other = this.box(other);
      if (!other) {
        return false;
      }
      if (this.__proto__ !== other.__proto__) {
        return false;
      }
      if (this.equals(other)) {
        return true;
      } else {
        return false;
      }
    };

    Numeric.prototype.inspect = function() {
      return new R.String("" + this.to_native());
    };

    Numeric.prototype.fdiv = function(other) {
      other = RCoerce.to_num_native(other);
      return this.to_f()['/'](other);
    };

    Numeric.prototype.floor = function() {
      return this.to_f().floor();
    };

    Numeric.prototype.magnitude = function() {
      return this.abs();
    };

    Numeric.prototype.modulo = function(other) {
      other = this.box(other);
      return this.minus(other['*'](this.div(other)));
    };

    Numeric.prototype.nonzero = function() {
      if (this.zero()) {
        return null;
      } else {
        return this;
      }
    };

    Numeric.prototype.quo = function(other) {
      var arr;
      other = this.box(other);
      if (other.zero()) {
        throw new Error("ZeroDivisionError");
      }
      arr = this.coerce(other);
      return this['/'](arr.first());
    };

    Numeric.prototype.rect = function() {
      if (arguments.length > 0) {
        throw R.ArgumentError["new"]();
      }
      return new R.Array([this, new R.Fixnum(0)]);
    };

    Numeric.prototype.rectangular = Numeric.prototype.rect;

    Numeric.prototype.remainder = function(other) {
      var mod;
      other = this.box(other);
      mod = this['%'](other);
      if (!mod.equals(0) && ((this.lt(0) && other.gt(0)) || (this.gt(0) && other.lt(0)))) {
        return mod.minus(other);
      } else {
        return mod;
      }
    };

    Numeric.prototype.round = function(n) {
      return this.to_f().round(n);
    };

    Numeric.prototype.step = function(limit, step, block) {
      if (step == null) {
        step = 1;
      }
      if ((block != null ? block.call : void 0) == null) {
        if ((step != null ? step.call : void 0) == null) {
          return this.to_enum('step', limit, step);
        }
      }
      _num.step(this.__native__, limit, step, block);
      return this;
    };

    Numeric.prototype.to_int = function() {
      return this.to_i();
    };

    Numeric.prototype.truncate = function() {
      return this.to_f().truncate();
    };

    Numeric.prototype.uminus = function() {
      return this.multiply(-1);
    };

    Numeric.prototype.zero = function() {
      return this.equals(0);
    };

    return Numeric;

  })(RubyJS.Object);

  RubyJS.Integer = (function(_super) {
    __extends(Integer, _super);

    function Integer() {
      _ref5 = Integer.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    Integer["new"] = function(value) {
      return new R.Integer(value);
    };

    Integer.isInteger = function(obj) {
      return this.isNumeric(obj) && (obj % 1 === 0);
    };

    Integer.prototype.is_integer = function() {
      return true;
    };

    Integer.prototype.unbox = function() {
      return this.to_native();
    };

    Integer.prototype.chr = function() {
      return new R.String(String.fromCharCode(this.to_native()));
    };

    Integer.prototype.denominator = function() {
      return new R.Fixnum(1);
    };

    Integer.prototype.downto = function(stop, block) {
      var err;
      try {
        stop = RCoerce.to_num_native(stop);
      } catch (_error) {
        err = _error;
        throw R.ArgumentError["new"]();
      }
      if ((block != null ? block.call : void 0) == null) {
        return R.Enumerator["new"](this, 'downto', stop);
      }
      _num.downto(this.__native__, stop, block);
      return this;
    };

    Integer.prototype.even = function() {
      return this.to_native() % 2 === 0;
    };

    Integer.prototype.gcd = function(other) {
      var n;
      other = R(other);
      __ensure_args_length(arguments, 1);
      this.__ensure_integer__(other);
      n = _num.gcd(this.__native__, other.to_native());
      return new R.Fixnum(n);
    };

    Integer.prototype.gcdlcm = function(other) {
      other = this.box(other);
      __ensure_args_length(arguments, 1);
      this.__ensure_integer__(other);
      return new R.Array([_num.gcd(this.__native__, other), _num.lcm(this.__native__, other)]);
    };

    Integer.prototype.lcm = function(other) {
      __ensure_args_length(arguments, 1);
      this.__ensure_integer__(R(other));
      return new RFixnum(_num.lcm(this.__native__, other));
    };

    Integer.prototype.numerator = function() {
      return new RFixnum(_num.numerator(this.__native__));
    };

    Integer.prototype.odd = function() {
      return !this.even();
    };

    Integer.prototype.ord = function() {
      return this;
    };

    Integer.prototype.next = function() {
      return this.plus(1);
    };

    Integer.prototype.pred = function() {
      return this.minus(1);
    };

    Integer.prototype.round = function(n) {
      if (n === void 0) {
        return this;
      }
      n = RCoerce.to_int_native(n);
      if (n > 0) {
        return this.to_f();
      } else if (n === 0) {
        return this;
      } else {
        return new R.Fixnum(_num.round(this.__native__, n));
      }
    };

    Integer.prototype.succ = Integer.prototype.next;

    Integer.prototype.times = function(block) {
      if ((block != null ? block.call : void 0) == null) {
        return this.to_enum('times');
      }
      return new R.Fixnum(_num.times(this.__native__, block));
    };

    Integer.prototype.to_i = function() {
      return this;
    };

    Integer.prototype.upto = function(stop, block) {
      var err;
      try {
        stop = RCoerce.to_num_native(stop);
      } catch (_error) {
        err = _error;
        throw R.ArgumentError["new"]();
      }
      if ((block != null ? block.call : void 0) == null) {
        return R.Enumerator["new"](this, 'upto', stop);
      }
      return _num.upto(this.__native__, stop, block);
    };

    Integer.prototype.toString = function() {
      return "" + (this.to_native());
    };

    Integer.prototype.__ensure_integer__ = function(other) {
      if ((other != null ? other.is_integer : void 0) == null) {
        throw RubyJS.TypeError["new"]();
      }
    };

    Integer.prototype.to_int = Integer.prototype.to_i;

    Integer.prototype.truncate = Integer.prototype.to_i;

    return Integer;

  })(RubyJS.Numeric);

  R.Fixnum = (function(_super) {
    __extends(Fixnum, _super);

    Fixnum.include(R.Comparable);

    function Fixnum(__native__) {
      this.__native__ = __native__;
    }

    Fixnum["new"] = function(val) {
      return new R.Fixnum(val);
    };

    Fixnum.try_convert = function(obj) {
      obj = R(obj);
      if (obj.to_int == null) {
        throw R.TypeError["new"]();
      }
      return obj;
    };

    Fixnum.__cache_fixnums__ = function(from, to) {
      var i, _k, _results;
      if (from == null) {
        from = -1;
      }
      if (to == null) {
        to = 256;
      }
      _results = [];
      for (i = _k = from; from <= to ? _k <= to : _k >= to; i = from <= to ? ++_k : --_k) {
        _results.push(this.__memoized_fixnums__[i] = new R.Fixnum(i));
      }
      return _results;
    };

    Fixnum.prototype.is_fixnum = function() {
      return true;
    };

    Fixnum.prototype.valueOf = function() {
      return this.__native__;
    };

    Fixnum.prototype.to_native = function() {
      return this.__native__;
    };

    Fixnum.prototype.valueOf = Fixnum.prototype.to_native;

    Fixnum.prototype.unbox = Fixnum.prototype.to_native;

    Fixnum.prototype.dup = function() {
      return Fixnum["new"](this.to_native());
    };

    Fixnum.prototype.equals = function(other) {
      if (R(other).is_fixnum == null) {
        return R(other).equals(this);
      } else {
        return this.cmp(other) === 0;
      }
    };

    Fixnum.prototype['==='] = Fixnum.prototype.equals;

    Fixnum.prototype.cmp = function(other) {
      if (typeof other !== 'number') {
        other = R(other);
        if (other.is_numeric == null) {
          return null;
        }
        if (other.to_int == null) {
          throw R.TypeError["new"]();
        }
        other = other.to_native();
      }
      if (this.to_native() < other) {
        return -1;
      } else if (this.to_native() > other) {
        return 1;
      } else {
        return 0;
      }
    };

    Fixnum.prototype.plus = function(other) {
      return R.Numeric.typecast(this.to_native() + RCoerce.to_num_native(other));
    };

    Fixnum.prototype.minus = function(other) {
      return R.Numeric.typecast(this.to_native() - RCoerce.to_num_native(other));
    };

    Fixnum.prototype['/'] = function(other) {
      var val;
      other = Fixnum.try_convert(other);
      if ((other.is_float != null) && other.zero()) {
        if (this.to_native() > 0) {
          return R('Infinity');
        } else {
          return R('-Infinity');
        }
      } else if (+other === 0) {
        throw R.ZeroDivisionError["new"]();
      } else {
        val = R.Numeric.typecast(this.to_native() / other.to_native());
        if (other.is_float != null) {
          return val;
        } else {
          return val.floor();
        }
      }
    };

    Fixnum.prototype['*'] = function(other) {
      return R.Numeric.typecast(this.to_native() * RCoerce.to_num_native(other));
    };

    Fixnum.prototype['**'] = function(other) {
      var val;
      other = this.box(other);
      val = this.box(Math.pow(this.to_native(), other.to_native()));
      if (other.is_float != null) {
        return val.to_f();
      } else {
        return val.to_i();
      }
    };

    Fixnum.prototype['%'] = function(other) {
      var division, fixnum, is_float, val;
      is_float = this.box(other).is_float != null;
      fixnum = Fixnum.try_convert(other);
      if (fixnum.zero()) {
        throw R.ZeroDivisionError["new"]();
      }
      fixnum = fixnum.to_int();
      division = this['/'](fixnum);
      val = this.minus(division.multiply(fixnum));
      if (is_float) {
        return val.to_f();
      } else {
        return val.to_i();
      }
    };

    Fixnum.prototype.fdiv = function(other) {
      other = R(other);
      if (other.is_numeric == null) {
        throw R.TypeError["new"]();
      }
      __ensure_args_length(arguments, 1);
      return this.to_f().divide(other.to_f());
    };

    Fixnum.prototype.object_id = function() {
      return this.__native__ * 2 + 1;
    };

    Fixnum.prototype.to_f = function() {
      return this.$Float(this.to_native());
    };

    Fixnum.prototype.to_s = function(base) {
      if (base == null) {
        base = 10;
      }
      base = this.box(base);
      if (base.lt(2) || base.gt(36)) {
        throw R.ArgumentError["new"]();
      }
      return this.box("" + (this.to_native().toString(base.to_native())));
    };

    Fixnum.__add_default_aliases__(Fixnum.prototype);

    return Fixnum;

  })(RubyJS.Integer);

  RFixnum = R.Fixnum;

  RubyJS.Float = (function(_super) {
    __extends(Float, _super);

    Float.include(R.Comparable);

    Float.INFINITY = 1.0 / 0.0;

    Float.NAN = 0.0 / 0.0;

    Float.DIG = 15;

    Float.EPSILON = 0.0000000000000002220446049250313080847263336181640625;

    Float.MANT_DIG = 53;

    Float.MAX_10_EXP = 308;

    Float.MIN_10_EXP = -307;

    Float.MAX_EXP = 1024;

    Float.MIN_EXP = -1021;

    Float.MAX = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368;

    Float.MANT_DIG = 53;

    Float.MIN = 2.225073858507201383090232717332404064219215980462331830553327416887204434813918195854283159012511020564067339731035811005152434161553460108856012385377718821130777993532002330479610147442583636071921565046942503734208375250806650616658158948720491179968591639648500635908770118304874799780887753749949451580451605050915399856582470818645113537935804992115981085766051992433352114352390148795699609591288891602992641511063466313393663477586513029371762047325631781485664350872122828637642044846811407613911477062801689853244110024161447421618567166150540154285084716752901903161322778896729707373123334086988983175067838846926092773977972858659654941091369095406136467568702398678315290680984617210924625396728515625e-308;

    Float.RADIX = 2;

    Float["new"] = function(f) {
      return new R.Float(f);
    };

    function Float(__native__) {
      this.__native__ = __native__;
    }

    Float.prototype.is_float = function() {
      return true;
    };

    Float.isFloat = function(obj) {
      return R.Numeric.isNumeric(obj) && !R.Integer.isInteger(obj);
    };

    Float.prototype.cmp = function(other) {
      if (this.box(other).is_numeric == null) {
        return null;
      }
      other = RCoerce.to_num_native(other);
      if (this.to_native() === other) {
        return 0;
      }
      if (this.to_native() < other) {
        return -1;
      }
      if (this.to_native() > other) {
        return 1;
      }
    };

    Float.prototype.equals = function(other) {
      other = this.box(other);
      return this.to_native() === other.to_native();
    };

    Float.prototype.plus = function(other) {
      return new Float(this.to_native() + RCoerce.to_num_native(other));
    };

    Float.prototype.minus = function(other) {
      return new Float(this.to_native() - RCoerce.to_num_native(other));
    };

    Float.prototype['*'] = function(other) {
      return new Float(this.to_native() * RCoerce.to_num_native(other));
    };

    Float.prototype['/'] = function(other) {
      return new Float(this.to_native() / RCoerce.to_num_native(other));
    };

    Float.prototype['**'] = function(other) {
      return new Float(Math.pow(this.to_native(), RCoerce.to_num_native(other)) + 0);
    };

    Float.prototype['%'] = function(other) {
      var div, inf, val;
      other = this.box(other);
      if (other.equals(0)) {
        throw new Error("ZeroDivisionError");
      }
      if (!this.finite()) {
        return this.box(Float.NAN).to_f();
      }
      if (inf = typeof other.infinite === "function" ? other.infinite() : void 0) {
        if (inf === -1) {
          return other;
        }
        if (inf === 1) {
          return this;
        }
      }
      div = this['/'](other).floor();
      val = this.to_native() - (div.to_native() * other.to_native());
      return new Float(val);
    };

    Float.prototype.arg = function() {
      if (this.nan()) {
        return this;
      } else if (this.__native__ < 0.0) {
        return new R.Float(Math.PI);
      } else {
        return new R.Float(0);
      }
    };

    Float.prototype.ceil = function() {
      return new R.Fixnum(Math.ceil(this.to_native()));
    };

    Float.prototype.inspect = function() {
      return this.to_s();
    };

    Float.prototype.dup = function() {
      return Float["new"](this.to_native());
    };

    Float.prototype.eql = function(other) {
      other = this.box(other);
      if (other.is_float == null) {
        return false;
      }
      return this.equals(other);
    };

    Float.prototype.finite = function() {
      return !(this.infinite() || this.nan());
    };

    Float.prototype.infinite = function() {
      if (this.to_native() === Float.INFINITY) {
        return 1;
      } else if (this.to_native() === -Float.INFINITY) {
        return -1;
      } else {
        return null;
      }
    };

    Float.prototype.nan = function() {
      return isNaN(this.to_native());
    };

    Float.prototype.to_f = function() {
      return this.dup();
    };

    Float.prototype.to_i = function() {
      if (this.to_native() < 0) {
        return this.ceil();
      } else {
        return this.floor();
      }
    };

    Float.prototype.floor = function() {
      return new R.Fixnum(Math.floor(this.__native__));
    };

    Float.prototype.quo = function(other) {
      __ensure_args_length(arguments, 1);
      other = this.box(other);
      return this.divide(other);
    };

    Float.prototype.round = function(n) {
      var multiplier, rounded;
      if (n == null) {
        n = 0;
      }
      n = RCoerce.to_int_native(n);
      if (this.infinite()) {
        throw new TypeError("FloatDomainError");
      }
      if (this.nan()) {
        throw new TypeError("RangeError");
      }
      if (n === 0) {
        return new R.Fixnum(Math.round(this.to_native()));
      }
      multiplier = Math.pow(10, n);
      rounded = Math.round(this.to_native() * multiplier) / multiplier;
      if (n > 0) {
        return new R.Float(rounded);
      } else {
        return new R.Fixnum(rounded);
      }
    };

    Float.prototype.to_s = function() {
      var inf, v;
      v = "" + this.to_native();
      if (this.nan()) {
        v = "NaN";
      } else if (inf = this.infinite()) {
        if (inf === -1) {
          v = "-Infinity";
        }
        if (inf === 1) {
          v = "Infinity";
        }
      } else if (v.indexOf('.') < 0) {
        v += ".0";
      }
      return this.$String(v);
    };

    Float.prototype.toString = function() {
      return this.to_native().toString();
    };

    Float.prototype.valueOf = function() {
      return this.__native__;
    };

    Float.prototype.to_native = function() {
      return this.__native__;
    };

    Float.prototype.unbox = Float.prototype.to_native;

    Float.prototype.angle = Float.prototype.arg;

    Float.prototype.fdiv = Float.prototype.quo;

    Float.prototype.magnitude = Float.prototype.abs;

    Float.prototype.phase = Float.prototype.arg;

    Float.prototype.to_int = Float.prototype.to_i;

    Float.prototype.truncate = Float.prototype.to_i;

    Float.prototype['==='] = Float.prototype.equals;

    Float.__add_default_aliases__(Float.prototype);

    return Float;

  })(RubyJS.Numeric);

  /*
  
  new RubyJS.Time(new Date(), 3600)
  
  JS Date objects have no support for timezones. R.Time emulates timezones using
  a second fake object that is offset by the user defined utc_offset.
  
  
  @example If local timezone is ICT (+07:00)
  
      t = R.Time.new(2012,12,24,12,0,0, "+01:00")
      t.__native__
      # => Mon Dec 24 2012 18:00:00 GMT+0700 (ICT)
      # t.__native__ has the correct timestamp for the local time.
      #              2012-12-24 12:00 (CET) - "+01:00 (CET)"
      #              2012-12-24 11:00 (UCT) + "+07:00 (ICT)"
      #              2012-12-24 18:00 (ICT)
      #
      t._tzdate
      # => Mon Dec 24 2012 12:00:00 GMT+0700 (ICT)
      #
      # t._tzdate holds the wrong timestamp but is useful to work with native JS
      # methods.
      #
      t.hour()      # => 12 (internally uses _tzdate.getHours())
  */


  RubyJS.Time = (function(_super) {
    __extends(Time, _super);

    Time.include(R.Comparable);

    Time.LOCALE = {
      'DAYS': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      'DAYS_SHORT': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      'MONTHS': [null, 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
      'MONTHS_SHORT': [null, 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      'AM': 'AM',
      'PM': 'PM',
      'AM_LOW': 'am',
      'PM_LOW': 'pm'
    };

    Time.TIME_ZONES = {
      'UTC': 0,
      'UT': 0,
      'GMT': 0,
      'EST': -5,
      'EDT': -4,
      'CST': -6,
      'CDT': -5,
      'MST': -7,
      'MDT': -6,
      'PST': -8,
      'PDT': -7
    };

    function Time(__native__, utc_offset) {
      this.__native__ = __native__;
      if (utc_offset != null) {
        this.__utc_offset__ = utc_offset;
        this._tzdate = R.Time._offset_to_local(this.__native__, this.__utc_offset__);
      } else {
        this._tzdate = this.__native__;
        this.__utc_offset__ = R.Time.__local_timezone__;
      }
    }

    Time.now = function() {
      return R.Time["new"]();
    };

    Time["new"] = function(year, month, day, hour, min, sec, utc_offset) {
      var date;
      if (arguments.length === 0) {
        return new R.Time(new Date());
      }
      if (year === null) {
        throw R.TypeError["new"]();
      }
      month || (month = 1);
      day || (day = 1);
      hour || (hour = 0);
      min || (min = 0);
      sec || (sec = 0);
      if (month > 12 || day > 31 || hour > 24 || min > 59 || sec > 59 || month < 0 || day < 0 || hour < 0 || min < 0 || sec < 0) {
        throw R.ArgumentError["new"]();
      }
      if (utc_offset != null) {
        utc_offset = this._parse_utc_offset(utc_offset);
        date = new Date(year, month - 1, day, hour, min, sec);
        date = this._local_to_offset(date, utc_offset);
      } else {
        date = new Date(year, month - 1, day, hour, min, sec);
        utc_offset = this.__local_timezone__;
      }
      return new R.Time(date, utc_offset);
    };

    Time._local_to_offset = function(date, utc_offset) {
      date = date.valueOf() + R.Time.__local_timezone__ * 1000;
      date = date - utc_offset * 1000;
      return new Date(date);
    };

    Time._offset_to_local = function(date, utc_offset) {
      date = date.valueOf() - R.Time.__local_timezone__ * 1000;
      date += utc_offset * 1000;
      return new Date(date);
    };

    Time._parse_utc_offset = function(offset) {
      var hour, mins, secs, sign, _ref6;
      if (offset == null) {
        return null;
      }
      offset = R(offset);
      secs = null;
      if ((offset.is_string != null) || (offset.to_str != null)) {
        offset = offset.to_str().to_native();
        if (!offset.match(/[\+|-]\d\d:\d\d/)) {
          throw R.ArgumentError["new"]();
        }
        sign = offset[0] === '-' ? -1 : 1;
        _ref6 = offset.split(':'), hour = _ref6[0], mins = _ref6[1];
        mins = parseInt(mins);
        hour = parseInt(hour.slice(1));
        secs = sign * (hour * 60 + mins) * 60;
      } else if ((offset.is_fixnum != null) || (offset.to_int != null)) {
        secs = offset.to_int().valueOf();
        if (Math.abs(secs) >= 86400) {
          throw R.ArgumentError["new"]();
        }
      } else {
        throw R.TypeError["new"]();
      }
      return Math.floor(secs);
    };

    Time.at = function(seconds, microseconds) {
      var msecs, secs;
      if (seconds === null) {
        throw R.TypeError["new"]();
      }
      if (microseconds !== void 0) {
        if (microseconds === null || (R(microseconds).is_string != null)) {
          throw R.TypeError["new"]();
        } else {
          microseconds = RCoerce.to_num_native(microseconds);
        }
      } else {
        microseconds = 0;
      }
      seconds = R(seconds);
      if (seconds.is_time != null) {
        secs = seconds.to_i();
        msecs = secs * 1000 + microseconds / 1000;
        return new R.Time(new Date(msecs), time.utc_offset());
      } else if (seconds.is_numeric != null) {
        secs = seconds.valueOf();
        msecs = secs * 1000 + microseconds / 1000;
        return new R.Time(new Date(msecs), this.__local_timezone__);
      } else {
        throw R.TypeError["new"]();
      }
    };

    Time.local = function(year, month, day, hour, min, sec) {
      return R.Time["new"](year, month, day, hour, min, sec, this.__local_timezone__);
    };

    Time.utc = function(year, month, day, hour, min, sec) {
      var date;
      date = new Date(Date.UTC(year, (month || 1) - 1, day || 1, hour || 0, min || 0, sec || 0));
      return new R.Time(date, 0);
    };

    Time.gm = Time.utc;

    Time.now = function() {
      return R.Time["new"]();
    };

    Time._local_timezone = function() {
      return this.__local_timezone__;
    };

    Time.__local_timezone__ = new Date().getTimezoneOffset() * -60;

    Time.__reset_local_timezone__ = function() {
      return this.__local_timezone__ = new Date().getTimezoneOffset() * -60;
    };

    Time.prototype.is_time = function() {
      return true;
    };

    Time.prototype.cmp = function(other) {
      var secs;
      secs = this.valueOf();
      other = other.valueOf();
      if (secs < other) {
        return -1;
      } else if (secs > other) {
        return 1;
      } else {
        return 0;
      }
    };

    Time.prototype.equals = function(other) {
      other = R(other);
      if (other.is_time == null) {
        return false;
      }
      return this.cmp(other) === 0;
    };

    Time.prototype.minus = function(other) {
      var tmstmp;
      if (other == null) {
        throw R.TypeError["new"]();
      }
      other = R(other);
      if (other.is_numeric != null) {
        tmstmp = this.valueOf() - (other.valueOf() * 1000);
        return new R.Time(new Date(tmstmp), this.__utc_offset__);
      } else if (other.is_time != null) {
        return new R.Float((this.valueOf() - other.valueOf()) / 1000);
      } else {
        throw R.TypeError["new"]();
      }
    };

    Time.prototype.plus = function(other) {
      var tmstmp, tpcast;
      if (other == null) {
        throw R.TypeError["new"]();
      }
      tpcast = R(other);
      if (typeof other !== 'number' || (tpcast.is_numeric == null)) {
        if ((tpcast.is_time == null) && (other.to_f != null)) {
          other = other.to_f();
        } else {
          throw R.TypeError["new"]();
        }
      }
      tmstmp = this.valueOf() + other.valueOf() * 1000;
      return new R.Time(new Date(tmstmp), this.__utc_offset__);
    };

    Time.prototype.asctime = function() {
      return this.strftime("%a %b %e %H:%M:%S %Y");
    };

    Time.prototype.ctime = Time.prototype.asctime;

    Time.prototype.dup = function() {
      return new R.Time(new Date(this.__native__), this.__utc_offset__);
    };

    Time.prototype.year = function() {
      return new R.Fixnum(_time.year(this._tzdate));
    };

    Time.prototype.month = function() {
      return new R.Fixnum(_time.month(this._tzdate));
    };

    Time.prototype.mon = Time.prototype.month;

    Time.prototype.monday = function() {
      return _time.monday(this._tzdate);
    };

    Time.prototype.tuesday = function() {
      return _time.tuesday(this._tzdate);
    };

    Time.prototype.wednesday = function() {
      return _time.wednesday(this._tzdate);
    };

    Time.prototype.thursday = function() {
      return _time.thursday(this._tzdate);
    };

    Time.prototype.friday = function() {
      return _time.friday(this._tzdate);
    };

    Time.prototype.saturday = function() {
      return _time.saturday(this._tzdate);
    };

    Time.prototype.sunday = function() {
      return _time.sunday(this._tzdate);
    };

    Time.prototype.day = function() {
      return new R.Fixnum(_time.day(this._tzdate));
    };

    Time.prototype.mday = Time.prototype.day;

    Time.prototype.getgm = function() {
      return new R.Time(this.__native__, 0);
    };

    Time.prototype.getutc = Time.prototype.getgm;

    Time.prototype.gmt = function() {
      return this.__utc_offset__ === 0;
    };

    Time.prototype.is_utc = Time.prototype.gmt;

    Time.prototype.gmt_offset = function() {
      return new R.Fixnum(this.__utc_offset__);
    };

    Time.prototype.gmtoff = Time.prototype.gmt_offset;

    Time.prototype.utc_offset = Time.prototype.gmt_offset;

    Time.prototype.gmtime = function() {
      this._tzdate = new Date(this.__native__ - this.__utc_offset__ * 1000);
      this.__utc_offset__ = 0;
      return this;
    };

    Time.prototype.hour = function() {
      return new R.Fixnum(_time.hour(this._tzdate));
    };

    Time.prototype.hour12 = function() {
      return new R.Fixnum(_time.hour12(this._tzdate));
    };

    Time.prototype.inspect = function() {
      if (this.gmt()) {
        return this.strftime('%Y-%m-%d %H:%M:%S UTC');
      } else {
        return this.strftime('%Y-%m-%d %H:%M:%S %z');
      }
    };

    Time.prototype.min = function() {
      return new R.Fixnum(_time.min(this._tzdate));
    };

    Time.prototype.sec = function() {
      return new R.Fixnum(_time.sec(this._tzdate));
    };

    Time.prototype.strftime = function(format) {
      var fill, locale, out, self;
      if (this.__utc_offset__ === new Date().getTimezoneOffset() * -60) {
        return new RString(_time.strftime(this.__native__, format));
      }
      locale = R.Time.LOCALE;
      fill = this._rjust;
      self = this;
      out = format.replace(/%(.)/g, function(_, flag) {
        var day, jtime;
        switch (flag) {
          case 'a':
            return locale.DAYS_SHORT[self.wday()];
          case 'A':
            return locale.DAYS[self.wday()];
          case 'b':
            return locale.MONTHS_SHORT[self.month()];
          case 'B':
            return locale.MONTHS[self.month()];
          case 'C':
            return self.year() % 100;
          case 'd':
            return fill(self.day());
          case 'D':
            return self.strftime('%m/%d/%y');
          case 'e':
            return fill(self.day(), ' ');
          case 'F':
            return self.strftime('%Y-%m-%d');
          case 'h':
            return locale.MONTHS_SHORT[self.month()];
          case 'H':
            return fill(self.hour());
          case 'I':
            return fill(self.hour12());
          case 'j':
            jtime = new Date(self.year(), 0, 1).getTime();
            return Math.ceil((self._tzdate.getTime() - jtime) / (1000 * 60 * 60 * 24));
          case 'k':
            return self.hour().to_s().rjust(2, ' ');
          case 'l':
            return fill(self.hour12(), ' ');
          case 'm':
            return fill(self.month());
          case 'M':
            return fill(self.min());
          case 'n':
            return "\n";
          case 'N':
            throw R.NotImplementedError["new"]();
            break;
          case 'p':
            if (self.hour() < 12) {
              return locale.AM;
            } else {
              return locale.PM;
            }
            break;
          case 'P':
            if (self.hour() < 12) {
              return locale.AM_LOW;
            } else {
              return locale.PM_LOW;
            }
            break;
          case 'r':
            return self.strftime('%I:%M:%S %p');
          case 'R':
            return self.strftime('%H:%M');
          case 'S':
            return fill(self.sec());
          case 't':
            return "\t";
          case 'T':
            return self.strftime('%H:%M:%S');
          case 'u':
            day = self.wday().to_native();
            if (day === 0) {
              return 7;
            } else {
              return day;
            }
            break;
          case 'v':
            return self.strftime('%e-%b-%Y');
          case 'w':
            return self.wday();
          case 'y':
            return self.year().to_s().slice(-2, 2);
          case 'Y':
            return self.year();
          case 'x':
            return self.strftime('%m/%d/%y');
          case 'X':
            return self.strftime('%H:%M:%S');
          case 'z':
            return self._offset_str();
          case 'Z':
            return self.zone();
          default:
            return flag;
        }
      });
      return new R.String(out);
    };

    Time.prototype.succ = function() {
      return R.Time.at(this.to_i().succ());
    };

    Time.prototype.to_i = function() {
      return R(this.__native__.getTime() / 1000).to_i();
    };

    Time.prototype.to_f = function() {
      return new R.Float(this.to_i() + ((this.valueOf() % 1000) / 1000));
    };

    Time.prototype.to_s = Time.prototype.inspect;

    Time.prototype.__utc_delta__ = function() {
      return this.gmt_offset() + R.Time.__local_timezone__;
    };

    Time.prototype.tv_sec = Time.prototype.to_i;

    Time.prototype.tv_usec = function() {
      return new R.Fixnum((this._tzdate.valueOf() % 1000) * 1000);
    };

    Time.prototype.usec = Time.prototype.tv_usec;

    Time.prototype.wday = function() {
      return new R.Fixnum(_time.wday(this._tzdate));
    };

    Time.prototype.yday = function() {
      var secs, ytd;
      ytd = new Date(this.year(), 0, 0);
      secs = this.__native__.getTime() + this.gmt_offset() * 1000 - ytd.getTime();
      return R(Math.floor(secs / 86400000));
    };

    Time.prototype.valueOf = function() {
      return this.__native__.valueOf();
    };

    Time.prototype.zone = function() {
      if (this.gmt()) {
        return new R.String('UTC');
      } else {
        throw R.NotImplementedError["new"]("Time#zone only supports UTC/GMT");
      }
    };

    Time.prototype._rjust = function(fixnum, str) {
      if (str == null) {
        str = '0';
      }
      return new R.String(fixnum + "").rjust(2, str);
    };

    Time.prototype._offset_str = function() {
      var hour, mins, sign;
      mins = this.gmt_offset() / 60;
      if (mins === 0) {
        return '+0000';
      }
      sign = mins > 0 ? '+' : '-';
      mins = Math.abs(mins);
      hour = this._rjust(Math.ceil(mins / 60));
      mins = this._rjust(mins % 60);
      return sign + hour + mins;
    };

    Time.__add_default_aliases__(Time.prototype);

    Time.prototype.eql = Time.prototype.equals;

    return Time;

  })(RubyJS.Object);

  RubyJS.pollute_global_with_shortcuts();

  RubyJS.pollute_global_with_kernel();

  root.puts = _puts;

}).call(this);
