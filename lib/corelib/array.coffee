# Array wraps a javascript array.
#
# @todo No proper support for handling recursive arrays. (e.g. a = [], a.push(a)).
#   Look for ArraySpecs.recursive_array in the specs.
# @todo #taint, #trust, #freeze does nothing
#
class RubyJS.Array extends RubyJS.Object
  @include RubyJS.Enumerable
  @include RubyJS.EnumerableArray, true

  # ---- RubyJSism ------------------------------------------------------------

  is_array: -> true


  iterator: () ->
    @__native__


  # ---- Constructors & Typecast ----------------------------------------------

  # Creates a new R.Array with a clone of the given array.
  #
  constructor: (@__native__ = [], recursive ) ->
    if recursive is true
      idx = -1
      len = @__native__.length
      while ++idx < len
        @__native__[idx] = R(@__native__[idx], recursive)

  # Returns a new array. In the first form, the new array is empty. In the
  # second it is created with size copies of obj (that is, size references to
  # the same obj). The third form creates a copy of the array passed as a
  # parameter (the array is generated by calling #to_ary on the parameter). In
  # the last form, an array of the given size is created. Each element in this
  # array is calculated by passing the element’s index to the given block and
  # storing the return value.
  #
  # @example
  #     R.Array.new()                  # => []
  #     R.Array.new(2)                 # => [null, null]
  #     R.Array.new(3, "A")            # => ['A','A','A']
  #     # only one copy of the object is created
  #     a = R.Array.new(2, R('a') )   # => ['a', 'a']
  #     a[0].capitalize_bang()
  #     a                             # => ['A', 'A']
  #     # here multiple copies are created
  #     a = R.Array.new(2, -> R('a'))
  #     squares = R.Array.new(5, (i) -> i.multiply(i)
  #     copy = R.Array.new(squares)
  #
  @new: (args...) ->
    block = R.__extract_block(args)
    throw R.ArgumentError.new() if args.length >= 3
    size = args[0]
    obj  = args[1]

    return new R.Array([])  if size is undefined
    throw R.TypeError.new() if obj isnt undefined && (@isNativeArray(size) || size.is_array?)

    return new R.Array(size) if @isNativeArray(size)
    return size.to_ary()     if size.to_ary? && obj is undefined

    size = CoerceProto.to_int_native(size)
    throw R.ArgumentError.new() if size < 0
    obj = null if obj is undefined

    ary = []
    idx = -1
    while ++idx < size
      ary[idx] = if block then block(R(idx)) else obj
    return new R.Array(ary)


  @typecast: (arr, recursive) ->
    new RubyJS.Array(arr, recursive)


  @isNativeArray: nativeArray.isArray or (obj) ->
    _toString_.call(obj) is '[object Array]'


  # Try to convert obj into an array, using to_ary method. Returns converted
  # array or nil if obj cannot be converted for any reason. This method can be
  # used to check if an argument is an array.
  #
  # @example
  #     R.Array.try_convert([1])      # => [1]
  #     R.Array.try_convert(R([1]))   # => [1]
  #     R.Array.try_convert("1")      # => null
  #
  # @todo Does currently not check if value from to_ary() is an Array
  #
  @try_convert: (obj) ->
    return obj          if obj.is_array?
    return @new(obj)    if @isNativeArray(obj)

    if obj.to_ary?
      # the correct behaviour currently breaks some tests.
      obj.to_ary() #.tap (a) -> throw R.TypeError.new() if a.is_array?
    else
      null

  # ---- Javascript primitives --------------------------------------------------

  valueOf: ->
    @__native__


  to_native: (recursive = false) ->
    if recursive
      for el in @__native__
        el = el.to_native(true) if el && el.to_native?
        el
    else
      # Clone array to avoid confusion
      @__native__.slice(0)


  # TODO: remove legacy behaviour
  unbox: (recursive = false) ->
    if recursive
      for el in @__native__
        el = el.unbox(true) if el && el.unbox?
        el
    else
      @__native__.slice(0)


  to_native_clone: -> @__native__.slice(0)

  # ---- Instance methods -----------------------------------------------------


  '==': (other) ->
    return true if this is other
    return false unless other?

    other = R(other)
    unless other.is_array?
      return false unless other.to_ary?
      return other['=='] this

    return false unless @size().equals other.size()

    md = @to_native_clone()
    od = other.to_native()

    i = 0
    total = i + @size().to_native()
    while i < total
      return false unless R(md[i])['=='](R(od[i]))
      i += 1

    true

  # Append—Pushes the given object on to the end of this array. This
  # expression returns the array itself, so several appends may be chained
  # together.
  #
  # @example
  #      R([ 1, 2 ]).append("c").append("d").append([3, 4])
  #      #=> [ 1, 2, "c", "d", [ 3, 4 ] ]
  #
  # @alias #append
  #
  '<<': (obj) ->
    @__native__.push(obj)
    this


  # Set Intersection—Returns a new array containing elements common to the two
  # arrays, with no duplicates.
  #
  # @example
  #     R([ 1, 1, 3, 5 ]).intersection [ 1, 2, 3 ]
  #     #=> [ 1, 3 ]
  #
  # @alias #intersection
  #
  # @todo Slow implementation, slight deviation Ruby implementation of equality check
  #
  '&': (other) ->
    other = CoerceProto.to_ary(other)
    arr   = new R.Array([])
    # TODO suboptimal solution.
    @each (el) -> arr.push(el) if other.include(el)
    arr.uniq()


  # Comparison—Returns an integer (-1, 0, or +1) if this array is less than,
  # equal to, or greater than other_ary. Each object in each array is compared
  # (using <=>). If any value isn’t equal, then that inequality is the return
  # value. If all the values found are equal, then the return is based on a
  # comparison of the array lengths. Thus, two arrays are “equal” according to
  # Array#<=> if and only if they have the same length and the value of each
  # element is equal to the value of the corresponding element in the other
  # array.
  #
  # @example
  #     R([ "a", "a", "c" ]   )['<=>'] [ "a", "b", "c" ]   #=> -1
  #     R([ 1, 2, 3, 4, 5, 6 ])['<=>'] [ 1, 2 ]            #=> +1
  #
  '<=>': (other) ->
    return null unless other?
    try
      other = CoerceProto.to_ary(other)
    catch e
      return null
    return 0    if @equals(other)

    other_total = other.size()
    # Thread.detect_recursion self, other do
    i = 0
    total = if other_total.lt(@size()) then other_total else @size()

    while total.gt(i)
      diff = R(@__native__[i])['<=>'] other.__native__[i]
      return diff unless diff == 0
      i += 1

    # subtle: if we are recursing on that pair, then let's
    # no go any further down into that pair;
    # any difference will be found elsewhere if need be
    @size()['<=>'] other_total


  # Returns the element at index. A negative index counts from the end of
  # self. Returns nil if the index is out of range. See also Array#[].
  #
  # @example
  #     a = R([ "a", "b", "c", "d", "e" ])
  #     a.at(0)     #=> "a"
  #     a.at(-1)    #=> "e"
  #
  # @return obj
  #
  at: (index) ->
    # UNSUPPORTED: @__ensure_args_length(arguments, 1)
    index = CoerceProto.to_int_native(index)

    if index < 0
      @__native__[@__size__() + index]
    else
      @__native__[index]


  # Removes all elements from self.
  #
  # @example
  #     a = R([ "a", "b", "c", "d", "e" ])
  #     a.clear()    #=> [ ]
  #
  # @return R.Array
  #
  clear: () ->
    @__ensure_args_length(arguments, 0)
    @replace []
    this


  # @todo does not copy the singleton class of the copied object
  clone: () -> @dup()


  # Invokes the block once for each element of self, replacing the element
  # with the value returned by block. See also Enumerable#collect.
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([ "a", "b", "c", "d" ])
  #     a.collect_bang (x) -> x+"!"
  #     a
  #     #=>  [ "a!", "b!", "c!", "d!" ]
  #
  # @alias #map_bang
  # @return self
  # @note some edge-cases not handled when breaking out from block.
  #
  collect_bang: (block) ->
    return @to_enum('collect_bang') unless block?.call?

    @replace @collect(block)


  # When invoked with a block, yields all combinations of length n of elements
  # from ary and then returns ary itself. The implementation makes no
  # guarantees about the order in which the combinations are yielded.
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([1, 2, 3, 4])
  #     a.combination(1).to_a()  #=> [[1],[2],[3],[4]]
  #     a.combination(2).to_a()  #=> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
  #     a.combination(3).to_a()  #=> [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
  #     a.combination(4).to_a()  #=> [[1,2,3,4]]
  #     a.combination(0).to_a()  #=> [[]] # one combination of length 0
  #     a.combination(5).to_a()  #=> []   # no combinations of length 5
  #     R([1, 2, 3, 4]).combination(3).to_a()
  #
  # @return R.Array
  #
  combination: (args...) ->
    block = @__extract_block(args)
    num   = CoerceProto.to_int_native args[0]

    return @to_enum('combination', num) unless block?.call?

    if num == 0
      block([])
    else if num == 1
      @each (args...) ->
        block.call(this, args)
    else if num == +@size()
      block @dup()
    else if num >= 0 && num < @size()
      num    = num
      stack  = (0 for i in [0..num+1])
      chosen = []
      lev    = 0
      done   = false
      stack[0] = -1
      until done
        chosen[lev] = @at(stack[lev+1])
        while lev < num - 1
          lev += 1
          stack[lev+1] = stack[lev] + 1
          chosen[lev] = @at(stack[lev+1])

        block.call(this, chosen.slice(0))
        lev += 1

        # this is begin ... while
        done = lev == 0
        stack[lev] += 1
        lev = lev - 1
        while (stack[lev+1] + num == @__size__() + lev + 1)
          done = lev == 0
          stack[lev] += 1
          lev = lev - 1
    this


  # Returns a copy of self with all nil elements removed.
  #
  # @example
  #     R([ "a", nil, "b", nil, "c", nil ]).compact()
  #     #=> [ "a", "b", "c" ]
  #
  compact: () ->
    @dup().tap (a) -> a.compact_bang()

  # Removes nil elements from the array. Returns nil if no changes were made,
  # otherwise returns ary.
  #
  # @example
  #     R([ "a", nil, "b", nil, "c" ]).compact_bang()
  #     #=> [ "a", "b", "c" ]
  #     R([ "a", "b", "c" ]).compact_bang()
  #     #=> null
  #
  # @return self or null if nothing changed
  #
  compact_bang: () ->
    length = @__native__.length

    arr = []
    # TODO: use while
    @each (el) ->
      arr.push(el) unless el is null
    @replace arr

    if length == arr.length then null else this


  # Appends the elements of other_ary to self.
  #
  # @example
  #     R([ "a", "b" ]).concat( ["c", "d"] )
  #     #=> [ "a", "b", "c", "d" ]
  #
  # @return R.Array
  #
  concat: (other) ->
    other = R(other).to_ary() # TODO: use CoerceProto
    @replace @__native__.concat(other.to_native())


  # Deletes items from self that are equal to obj. If any items are found,
  # returns obj. If the item is not found, returns nil. If the optional code
  # block is given, returns the result of block if the item is not found. (To
  # remove nil elements and get an informative return value, use compact!)
  #
  # @example
  #     a = R([ "a", "b", "b", "b", "c" ])
  #     a.delete("b")                   #=> "b"
  #     a                               #=> ["a", "c"]
  #     a.delete("z")                   #=> nil
  #     a.delete("z", -> 'not found')   #=> "not found"
  #
  delete: (args...) ->
    block   = @__extract_block(args)
    orig    = args[0]
    obj     = R(orig)
    total   = @__native__.length
    deleted = []

    i = 0

    while i < total
      if obj.equals(@__native__[i])
        deleted.push(i)
      i += 1

    if deleted.length > 0
      @delete_at(i) for i in deleted.reverse()
      return orig

    if block then block() else null

  # Deletes the element at the specified index, returning that element, or nil
  # if the index is out of range. See also Array#slice!.
  #
  # @example
  #    a = R.w('ant bat cat dog')
  #    a.delete_at(2)    #=> "cat"
  #    a                 #=> ["ant", "bat", "dog"]
  #    a.delete_at(99)   #=> null
  #
  # @return obj or null
  #
  delete_at: (idx) ->
    idx = CoerceProto.to_int_native(idx)

    idx = idx + @__size__() if idx < 0
    return null if idx < 0 or idx >= @__size__()

    val = @__native__[idx]
    @replace @__native__.slice(0, idx).concat(@__native__.slice(idx+1))
    val


  # Deletes every element of self for which block evaluates to true. The array
  # is changed instantly every time the block is called and not after the
  # iteration is over. See also Array#reject!
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([ "a", "b", "c" ])
  #     a.delete_if (x) -> x >= "b"
  #     #=> ["a"]
  #
  # @return [R.Array, R.Enumerator] when no block
  #
  delete_if: (block) ->
    @replace @reject(block)


  dup: () -> new RubyJS.Array(@__native__.slice(0))


  # @todo should not call #to_ary on its argument, but it does through boxing, Array.try_convert
  eql: (other) ->
    return true if @equals(other)
    other = R(other)
    return false unless other.is_array?
    return false unless @size().equals other.size()

    # TODO: no nested loop detection
    other_arr = other.to_native()
    @catch_break (breaker) ->
      i = 0
      @each (x) ->
        breaker.break(false) unless R(x).eql(other_arr[i])
        i += 1
      true


  # Same as Array#each, but passes the index of the element instead of the
  # element itself.
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([ "a", "b", "c" ])
  #     a.each_index (x) -> R.puts "#{x} -- "
  #     # out: 0 -- 1 -- 2 --
  #
  each_index: (block) ->
    if block && block.call?
      idx = -1
      len = @__native__.length
      while ++idx < len
        block(idx)
      this
    else
      @to_enum('each_index')


  # Calls block once for each element in self, passing that element as a
  # parameter.
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([ "a", "b", "c" ])
  #     a.each (x) -> R.puts "#{x} -- "
  #     # out: a -- b -- c --
  #
  # @alias #each
  #
  each: (block) ->
    # block = R.string_to_proc(block)
    if block && block.call?

      if block.length > 0 # 'if' needed for to_a
        block = Block.supportMultipleArgs(block)

      idx = -1
      while ++idx < @__native__.length
        block(@__native__[idx])

      this
    else
      @to_enum()


  # Alias for R.Array#[] R.Array#slice
  #
  # Element Reference—Returns the element at index, or returns a subarray
  # starting at start and continuing for length elements, or returns a
  # subarray specified by range. Negative indices count backward from the end
  # of the array (-1 is the last element). Returns nil if the index (or
  # starting index) are out of range.
  #
  # @example
  #     a = R([ "a", "b", "c", "d", "e" ])
  #     a.get(2) +  a.get(0) + a.get(1)    #=> "cab"
  #     a.get(6)                   #=> nil
  #     a.get(1, 2)                #=> [ "b", "c" ]
  #     a.get(R.rng(1,3))          #=> [ "b", "c", "d" ]
  #     a.get(R.rng(4,7))          #=> [ "e" ]
  #     a.get(R.rng(6,10))         #=> nil
  #     a.get(-3, 3)               #=> [ "c", "d", "e" ]
  #     # special cases
  #     a.get(5)                   #=> nil
  #     a.get(5, 1)                #=> []
  #     a.get(R.rng(5,10))         #=> []
  #
  get: (a, b) ->
    @slice(a,b)


  # TODO: IMPLEMENT remaining arguments!!
  #
  #
  set: (idx, obj) ->
    if idx.is_range?
      return @set$range(idx, obj)
    if arguments.length is 3
      return @set$int$int.apply(this, arguments)

    idx = CoerceProto.to_int_native(idx)
    @__native__[idx] = obj

    obj


  # @private
  set$range: (rng, obj) ->
    throw R.NotImplementedError.new()


  # @private
  set$int$int: (start, length, obj) ->
    throw R.NotImplementedError.new()


  # Returns true if self contains no elements.
  #
  # @example
  #     [].empty?   #=> true
  #
  # @return [true,false]
  #
  empty: () ->
    @__native__.length is 0

  # Tries to return the element at position index. If the index lies outside
  # the array, the first form throws an IndexError exception, the second form
  # returns default, and the third form returns the value of invoking the
  # block, passing in the index. Negative values of index count from the end
  # of the array.
  #
  # @example
  #     a = R([ 11, 22, 33, 44 ])
  #     a.fetch(1)               #=> 22
  #     a.fetch(-1)              #=> 44
  #     a.fetch(4, 'cat')        #=> "cat"
  #     a.fetch(4, (i) -> i*i))  #=> 16
  #
  fetch: (args...) ->
    block    = @__extract_block(args)
    orig     = args[0]
    idx      = CoerceProto.to_int_native(args[0])
    _default = args[1]

    len = @__size__()
    idx = idx + len if idx < 0

    if idx < 0 or idx >= len
      return block(orig) if block?.call?
      return _default   unless _default is undefined

      throw R.IndexError.new()

    @at(idx)

  # Fills array with obj or block.
  #
  #     fill(obj) → ary
  #     fill(obj, start [, length]) → ary
  #     fill(obj, range ) → ary
  #     fill (index) -> block  → ary
  #     fill(start [, length],  (index) -> block  → ary
  #     # not yet implemented:
  #     fill(range, (index) -> block ) → ary
  #
  # The first three forms set the selected elements of self (which may be the
  # entire array) to obj. A start of nil is equivalent to zero. A length of
  # nil is equivalent to self.length. The last three forms fill the array with
  # the value of the block. The block is passed the absolute index of each
  # element to be filled. Negative values of start count from the end of the
  # array.
  #
  # @example
  #     a = R([ "a", "b", "c", "d" ])
  #     a.fill("x")               #=> ["x", "x", "x", "x"]
  #     a.fill("z", 2, 2)         #=> ["x", "x", "z", "z"]
  #     # a.fill("y", 0..1)         #=> ["y", "y", "z", "z"]
  #     a.fill (i) -> i*i         #=> [0, 1, 4, 9]
  #     a.fill(-2) (i) -> i*i*i   #=> [0, 1, 8, 27]
  #
  # @todo implement fill(range, ...)
  #
  fill: (args...) ->
    throw R.ArgumentError.new() if args.length == 0

    block = @__extract_block(args)

    if block
      throw R.ArgumentError.new() if args.length >= 3
      one = args[0]; two = args[1]
    else
      throw R.ArgumentError.new() if args.length > 3
      obj = args[0]; one = args[1]; two = args[2]

    size = @__size__()

    if one?.is_range?
      # TODO: implement fill with range
      throw R.NotImplementedError.new()

    else if one isnt undefined && one isnt null
      left = CoerceProto.to_int_native(one)
      left = left + size    if left < 0
      left = 0              if left < 0

      if two isnt undefined && two isnt null
        try
          right = CoerceProto.to_int_native(two)
        catch e
          throw R.ArgumentError.new("second argument must be a Fixnum")
        return this if right is 0
        right = right + left
      else
        right = size
    else
      left  = 0
      right = size

    total = right

    if right > size # pad with nul if length is greater than array
      fill = @__native_array_with__(right - size, null)
      @concat( fill )
      total = right

    i = left
    if block
      while total > i
        v = block.call(this, i)
        @__native__[i] = if v is undefined then null else v
        i += 1
    else
      while total > i
        @__native__[i] = obj
        i += 1
    this

  # Returns a new array that is a one-dimensional flattening of this array
  # (recursively). That is, for every element that is an array, extract its
  # elements into the new array. If the optional level argument determines the
  # level of recursion to flatten.
  #
  # @example
  #     s = R([ 1, 2, 3 ])           #=> [1, 2, 3]
  #     t = R([ 4, 5, 6, [7, 8] ])   #=> [4, 5, 6, [7, 8]]
  #     a = R([ s, t, 9, 10 ])       #=> [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
  #     a.flatten()                  #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  #     a = R([ 1, 2, [3, [4, 5] ] ])
  #     a.flatten(1)                 #=> [1, 2, 3, [4, 5]]
  #
  # TODO: IMPORTANT!
  # @todo fails for [undefined, null]
  # @todo do not typecast elements!
  #
  flatten: (recursion = -1) ->
    recursion = R(recursion)

    arr = new R.Array([])

    @each (el) ->
      el = R(el)
      if el?.to_ary? && !recursion.equals(0)
        el.to_ary().flatten(recursion.minus(1)).each (e) -> arr.push(e)
      else
        arr.push(el)
    arr

  # Inserts the given values before the element with the given index (which
  # may be negative).
  #
  # @example
  #     a = R.w('a b c d')
  #     a.insert(2, 99)         #=> ["a", "b", 99, "c", "d"]
  #     a.insert(-2, 1, 2, 3)   #=> ["a", "b", 99, "c", 1, 2, 3, "d"]
  #
  insert: (idx, items...) ->
    throw R.ArgumentError.new() if idx is undefined

    return this if items.length == 0

    # Adjust the index for correct insertion
    idx = CoerceProto.to_int_native(idx)
    idx = idx + @__size__() + 1 if idx < 0 # Negatives add AFTER the element

    # TODO: add message "#{idx} out of bounds"
    throw R.IndexError.new() if idx < 0

    before = @__native__.slice(0, idx)

    if idx > before.length
      fill = @__native_array_with__(idx - before.length, null)
      before = before.concat( fill )

    after  = @__native__.slice(idx)
    @replace before.concat(items).concat(after)


  # Creates a string representation of self.
  #
  # Also aliased as: {#to_s}
  #
  # @example
  #     R([1,2]).inspect()     # => '[1, 2]'
  #
  inspect: () ->
    R("[#{@map((e) -> R.inspect(e) ).join(', ')}]")


  # Returns a string created by converting each element of the array to a
  # string, separated by sep.
  #
  # @example
  #     R([ "a", "b", "c"]).join()      # => "abc"
  #     R([ "a", "b", "c"]).join(null)  # => "abc"
  #     R([ "a", "b", "c"]).join("-")   # => "a-b-c"
  #     # joins nested arrays
  #     R([1,[2,[3,4]]]).join('.')      # => '1.2.3.4'
  #     # Default separator R['$,'] (in ruby: $,)
  #     R['$,']                        # => null
  #     R([ "a", "b", "c"]).join()      # => "abc"
  #     R['$,'] = '|'                  # => '|'
  #     R([ "a", "b", "c"]).join()      # => "a|b|c"
  #
  # @todo Does not ducktype via #to_str, #to_ary, #to_s or throw error
  #
  join: (separator) ->
    return R('') if @empty()
    separator = R['$,']  if separator is undefined
    separator = ''       if separator is null
    separator = CoerceProto.to_str_native(separator)

    new R.String(@__native__.join(separator))


  # Deletes every element of self for which block evaluates to false. See also
  # Array#select!
  #
  # If no block is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([1,2,3,4])
  #     a.keep_if (v) -> i < 3   # => [1,2,3]
  #     a.keep_if  -> true       # => a # returns self if not changed
  #
  keep_if: (block) ->
    return @to_enum('keep_if') unless block?.call?

    ary = []
    # TODO: use while
    @each (el) ->
      ary.push(el) unless R.falsey(block(el))

    if @__size__() is ary.length then this else @replace(ary)

  # Array Difference - Returns a new array that is a copy of the original
  # array, removing any items that also appear in other_ary. (If you need set-
  # like behavior, see the library class Set.)
  #
  # @note minus checks for identity using other.include(el), which differs slightly
  #   from the reference which uses #hash and #eql?
  #
  # @example
  #     R([ 1, 1, 2, 2, 3, 3, 4, 5 ]) - [ 1, 2, 4 ]  #=>  [ 3, 3, 5 ]
  #
  # @todo recursive arrays not tested
  #
  minus: (other) ->
    other = CoerceProto.to_ary(other)

    ary = []
    @each (el) ->
      ary.push(el) unless other.include(el)

    new R.Array(ary)


  # Repetition—With a String argument, equivalent to self.join(str).
  # Otherwise, returns a new array built by concatenating the int copies of
  # self.
  #
  # @example
  #     R([ 1, 2, 3 ]).multiply 3    # => [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
  #     R([ 1, 2, 3 ]).multiply ","  # => "1,2,3"
  #
  multiply: (multiplier) ->
    @__ensure_args_length(arguments, 1)
    throw R.TypeError.new() if multiplier is null

    multiplier = R(multiplier)
    if multiplier.to_str?
      return @join(multiplier)
    else
      multiplier = CoerceProto.to_int_native(multiplier)

      throw R.ArgumentError.new("count cannot be negative") if multiplier < 0

      total = @__size__()
      if total is 0
        return new R.Array([])
      else if total is 1
        return @dup()

      ary = []
      arr = @__native__

      idx = -1
      while ++idx < multiplier
        ary = ary.concat(arr)

      return new R.Array(ary)

  # Returns the last element(s) of self. If the array is empty, the first form
  # returns nil.
  #
  # @example
  #     a = R([ "w", "x", "y", "z" ])
  #     a.last()     #=> "z"
  #     a.last(2)    #=> ["y", "z"]
  #
  last: (n) ->
    len = @__size__()
    if len < 1
      return null if n is undefined
      return new R.Array([])

    return @at(-1) if n is undefined

    n = CoerceProto.to_int_native(n)
    return new R.Array([]) if n is 0

    throw R.ArgumentError.new("count must be positive") if n < 0

    n = len if n > len
    new R.Array( @__native__[-n.. -1] )


  # @todo Not yet implemented
  permutation: (args...) ->
    throw R.NotImplementedError.new()
  #   block = @__extract_block(args)
  #   num   = args[0]
  #   return @to_enum('permutation', num) unless block?.call?

  #   num = if num is undefined then @size() else CoerceProto.to_int(num)

  #   if num.lt(0) || @size().lt num
  #     # no permutations, yield nothing
  #   else if num.equals 0
  #     # exactly one permutation: the zero-length array
  #     block.call(this, new R.Array([]))
  #   else if num.equals 1
  #     # this is a special, easy case
  #     @each (val) -> block.call(this, R([val]))
  #   else
  #     # this is the general case
  #     perm = R.Array.make(num)
  #     used = R.Array.make(@size(), false)

  #     if block
  #       # offensive (both definitions) copy.
  #       offensive = @dup()
  #       offensive.__permute__(num, perm, R(0), used, block)
  #     # else
  #     #   @__permute__(num, perm, R(0), used)

  #   this

  # # @private
  # __permute__: (num, perm, index, used, block) ->
  #   # Recursively compute permutations of r elements of the set [0..n-1].
  #   # When we have a complete permutation of array indexes, copy the values
  #   # at those indexes into a new array and yield that array.
  #   #
  #   # num: the number of elements in each permutation
  #   # p: the array (of size num) that we're filling in
  #   # index: what index we're filling in now
  #   # used: an array of booleans: whether a given index is already used
  #   #
  #   # Note: not as efficient as could be for big num.
  #   self = this
  #   @size().times (i) ->
  #     unless used[i]
  #       perm[index] = i
  #       if index.lt(num.minus 1)
  #         used[i] = true
  #         self.__permute__(num, perm, index.plus(1), used, block)
  #         used[i] = false
  #       else
  #         block.apply(this, self.values_at(perm...)...)


  # Concatenation—Returns a new array built by concatenating the two arrays
  # together to produce a third array.
  #
  # @example
  #     R([ 1, 2, 3 ]).plus [ 3, 4 ]     #=> [ 1, 2, 3, 3, 4 ]
  #     R([ 1, 2, 3 ])['+']([ 3, 4 ])    #=> [ 1, 2, 3, 3, 4 ]
  #
  # @note recursive arrays untested.
  #
  plus: (other) ->
    @concat(other)


  # Removes the last element from self and returns it, or nil if the array is empty.
  #
  # If a number n is given, returns an array of the last n elements (or less)
  # just like array.slice!(-n, n) does.
  #
  # @example
  #     a = R([ "a", "b", "c", "d" ])
  #     a.pop()     # => "d"
  #     a.pop(2)    # => ["b", "c"]
  #     a           # => ["a"]
  #
  # @todo check for recursive arrays
  #
  pop: (many) ->
    throw R.ArgumentError.new() if arguments.length > 1

    if many is undefined
      @__native__.pop()
    else
      many = CoerceProto.to_int_native(many)
      throw R.ArgumentError.new("negative array size") if many < 0
      first = @__size__() - many
      first = 0 if first < 0
      @slice_bang(first, many)


  # Returns an array of all combinations of elements from all arrays. The
  # length of the returned array is the product of the length of self and the
  # argument arrays. If given a block, product will yield all combinations and
  # return self instead.
  #
  # @example
  #     R( [1,2,3] ).product([4,5])       #=> [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
  #     R( [1,2]   ).product([1,2])       #=> [[1,1],[1,2],[2,1],[2,2]]
  #     R( [1,2]   ).product([3,4],[5,6]) #=> [[1,3,5],[1,3,6],[1,4,5],[1,4,6],
  #                                       #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]
  #     R( [1,2] ).product()              #=> [[1],[2]]
  #     R( [1,2] ).product([])            #=> []
  #
  # @todo does not check if the result size will fit in an Array.
  #
  product: (args...) ->
    block = @__extract_block(args)
    args = R.$Array_r(args).reverse()
    throw R.TypeError.new() unless args.all (a) -> a.to_ary?
    args.map_bang (a) -> a.to_ary()
    result = new R.Array([])
    args.push(this)

    # Implementation notes: We build a block that will generate all the
    # combinations by building it up successively using "inject" and starting
    # with one responsible to append the values.
    outer = args.inject result.push, (trigger, values) ->
      (partial) ->
        values.each (val) ->
          trigger.call(result, partial.dup().append(val))

    outer( new R.Array([]) )
    if block
      block_result = this
      result.each (v) ->
        block_result.append block(v)
      block_result
    else
      result

  # Append—Pushes the given object(s) on to the end of this array. This
  # expression returns the array itself, so several appends may be chained
  # together.
  #
  # @example
  #     a = R([ "a", "b", "c" ])
  #     a.push("d", "e", "f")
  #     #=> ["a", "b", "c", "d", "e", "f"]
  #
  push: ->
    @__native__.push.apply(@__native__, arguments)
    this


  # Searches through the array whose elements are also arrays. Compares obj
  # with the second element of each contained array using ==. Returns the
  # first contained array that matches. See also Array#assoc.
  #
  # @example
  #     a = R([ [ 1, "one"], [2, "two"], [3, "three"], ["ii", "two"] ])
  #     a.rassoc("two")    #=> [2, "two"]
  #     a.rassoc("four")   #=> nil
  #
  rassoc: (obj) ->
    obj = R(obj)

    @catch_break (breaker) ->
      @each (elem) ->
        if elem.is_array? and R(elem.at(1))?['=='](obj)
          breaker.break(elem)
      null

  # Returns the index of the last object in self == to obj. If a block is
  # given instead of an argument, returns index of first object for which
  # block is true, starting from the last object. Returns nil if no match is
  # found. See also Array#index.
  #
  # If neither block nor argument is given, an enumerator is returned instead.
  #
  # @example
  #     a = R([ "a", "b", "b", "b", "c" ])
  #     a.rindex("b")             # => 3
  #     a.rindex("z")             # => nil
  #     a.rindex (x) -> x == "b"  # => 3
  #
  # @note does not check if array has changed.
  #
  rindex: (other) ->
    return @to_enum('rindex') if other is undefined

    if other.call?
      block = other
      len   = @__size__()
      ridx  = @catch_break (breaker) ->
        idx = -1
        @reverse_each (el) ->
          idx += 1
          unless R.falsey(block(el))
            breaker.break(idx)
        null
    else
      # TODO: 2012-11-06 use a while loop with idx counting down
      ridx = @catch_break (breaker) ->
        idx = -1
        @reverse_each (el) ->
          idx += 1
          if R(el)['=='](other)
            breaker.break(idx)
        null

    if ridx is null then null else R(@__size__() - ridx - 1)

  # Choose a random element or n random elements from the array. The elements
  # are chosen by using random and unique indices into the array in order to
  # ensure that an element doesn’t repeat itself unless the array already
  # contained duplicate elements. If the array is empty the first form returns
  # nil and the second form returns an empty array.
  #
  # If rng is given, it will be used as the random number generator.
  #
  #     R([1,2,3]).sample()    # => 2
  #     R([1,2,3]).sample(2)   # => [3,1]
  #     R([1,2,3]).sample(4)   # => [2,1,3]
  #
  sample: (n, range = undefined) ->
    return @at(@rand(@size())) if n is undefined

    n = CoerceProto.to_int_native(n)
    throw R.ArgumentError.new() if n < 0

    size = @__size__()
    n    = size if n > size
    ary  = @to_native_clone()

    idx = -1
    while ++idx < n
      ridx = idx + R.rand(size - idx) # Random idx
      tmp  = ary[idx]
      ary[idx]  = ary[ridx]
      ary[ridx] = tmp

    new R.Array(ary).slice(0, n)

  # Equivalent to Array#delete_if, deleting elements from self for which the
  # block evaluates to true, but returns nil if no changes were made. The array
  # is changed instantly every time the block is called and not after the
  # iteration is over. See also Enumerable#reject and Array#delete_if.
  #
  # If no block is given, an enumerator is returned instead.
  #
  reject_bang: (block) ->
    return @to_enum('reject_bang') unless block?.call?
    ary = @reject(block)
    if ary.__size__() is @__size__() then null else @replace(ary)

  # Replaces the contents of self with the contents of other_ary, truncating
  # or expanding if necessary.
  #
  # @example
  #     a = R([ "a", "b", "c", "d", "e" ])
  #     a.replace([ "x", "y", "z" ])   # => ["x", "y", "z"]
  #     a                              # => ["x", "y", "z"]
  #     a.replace(R([1]))             # => [1]
  #
  replace: (val) ->
    @__ensure_args_length(arguments, 1)
    # TODO: Use CoerceProto.to_ary_native
    @__native__ = if val.to_ary? then val.to_ary().to_native().slice(0) else val.slice(0)
    this


  # Returns a new array containing self‘s elements in reverse order.
  #
  #     R([ "a", "b", "c" ]).reverse()   #=> ["c", "b", "a"]
  #     R([ 1 ]).reverse()               #=> [1]
  #
  reverse: () ->
    @dup().tap (w) -> w.reverse_bang()


  # Reverses self in place.
  #
  #     a = R([ "a", "b", "c" ])
  #     a.reverse_bang()   #=> ["c", "b", "a"]
  #     a                  #=> ["c", "b", "a"]
  #
  reverse_bang: () ->
    @replace @__native__.reverse()
    this

  # Same as Array#each, but traverses self in reverse order.
  #
  #     a = R([ "a", "b", "c" ])
  #     a.reverse_each (x) -> R.puts "#{x} "
  #     # out: c b a
  #
  reverse_each: (block) ->
    return @to_enum('reverse_each') unless block && block.call?

    if block && block.call?

      if block.length > 0 # if needed for to_a
        block = Block.supportMultipleArgs(block)

      idx = @__native__.length
      while idx--
        block(@__native__[idx])

      this
    else
      @to_enum()


  # Returns new array by rotating self so that the element at cnt in self is
  # the first element of the new array. If cnt is negative then it rotates in
  # the opposite direction.
  #
  # @example
  #     a = R([ "a", "b", "c", "d" ])
  #     a.rotate()       # => ["b", "c", "d", "a"]
  #     a                # => ["a", "b", "c", "d"]
  #     a.rotate(2)      # => ["c", "d", "a", "b"]
  #     a.rotate(-3)     # => ["b", "c", "d", "a"]
  #
  rotate: (cnt) ->
    cnt = 1 if cnt is undefined
    cnt = CoerceProto.to_int_native(cnt)

    ary = @dup()
    return ary             if @__size__() is 1
    return new R.Array([]) if @empty()

    idx = cnt % ary.__size__()

    sliced = ary.slice(R.rng(0, idx, true))
    ary.slice(R.rng(idx,-1)).concat(sliced)

  # Rotates self in place so that the element at cnt comes first, and returns
  # self. If cnt is negative then it rotates in the opposite direction.
  #
  #     a = R([ "a", "b", "c", "d" ])
  #     a.rotate_bang()      # => ["b", "c", "d", "a"]
  #     a                    # => ["b", "c", "d", "a"]
  #     a.rotate_bang(2)     # => ["d", "a", "b", "c"]
  #     a.rotate_bang(-3)    # => ["a", "b", "c", "d"]
  #
  rotate_bang: (cnt) ->
    if cnt is undefined
      cnt = 1
      @replace @rotate(cnt)
    else
      cnt = CoerceProto.to_int_native(cnt)
      return this if cnt is 0 or cnt is 1
      @replace @rotate(cnt)


  # Invokes the block passing in successive elements from self, deleting
  # elements for which the block returns a false value. It returns self if
  # changes were made, otherwise it returns nil. See also Array#keep_if
  #
  # If no block is given, an enumerator is returned instead.
  select_bang: (block) ->
    return @to_enum('select_bang') unless block?.call?
    ary = @select(block)
    if ary.__size__() is @__size__() then null else @replace(ary)


  # Invokes the block passing in successive elements from self, returning an
  # array containing those elements for which the block returns a true value
  # (equivalent to Enumerable#select).
  #
  # If no block is given, an enumerator is returned instead.
  #
  #     a = R.w('a b c d e f')
  #     a.select (v) -> v.match /[aeiou]/   #=> ["a", "e"]
  #
  #

  # Returns the first element of self and removes it (shifting all other
  # elements down by one). Returns nil if the array is empty.
  #
  # If a number n is given, returns an array of the first n elements (or less)
  # just like array.slice!(0, n) does.
  #
  #     args = R([ "-m", "-q", "filename" ])
  #     args.shift()     #=> "-m"
  #     args             #=> ["-q", "filename"]
  #
  #     args = R([ "-m", "-q", "filename" ])
  #     args.shift(2)  #=> ["-m", "-q"]
  #     args           #=> ["filename"]
  #
  shift: (n) ->
    throw R.ArgumentError.new() if arguments.length > 1

    if n is undefined
      el = @__native__[0]
      @replace @__native__.slice(1)
      el
    else
      n = CoerceProto.to_int_native(n)
      throw R.ArgumentError.new() if n < 0
      ret  = @first(n)
      @replace @__native__.slice(n)
      ret


  # Returns a new array with elements of this array shuffled.
  #
  #     a = [ 1, 2, 3 ]           #=> [1, 2, 3]
  #     a.shuffle()                 #=> [2, 3, 1]
  #
  shuffle: ->
    @dup().tap (ary) -> ary.shuffle_bang()

  # Shuffles elements in self in place. If rng is given, it will be used as
  # the random number generator.
  #
  shuffle_bang: ->
    size = @__size__()
    arr  = @__native__

    idx = -1
    while ++idx < size
      rnd = idx + R.rand(size - idx)
      tmp = arr[idx]
      arr[idx] = arr[rnd]
      arr[rnd] = tmp
    this

  # Length of array
  size: ->
    R(@__native__.length)


  # Length of array as literal
  __size__: ->
    @__native__.length


  # Element Reference—Returns the element at index, or returns a subarray
  # starting at start and continuing for length elements, or returns a
  # subarray specified by range. Negative indices count backward from the end
  # of the array (-1 is the last element). Returns null if the index (or
  # starting index) are out of range.
  #
  # @example
  #     a = R([ "a", "b", "c", "d", "e" ])
  #     a.slice(2) +  a[0] + a[1]    #=> "cab"
  #     a.slice(6)                   #=> null
  #     a.slice(1, 2)                #=> [ "b", "c" ]
  #     a.slice(1..3)                #=> [ "b", "c", "d" ]
  #     a.slice(4..7)                #=> [ "e" ]
  #     a.slice(6..10)               #=> null
  #     a.slice(-3, 3)               #=> [ "c", "d", "e" ]
  #     # special cases
  #     a.slice(5)                   #=> null
  #     a.slice(5, 1)                #=> []
  #     a.slice(5..10)               #=> []
  #
  slice: (idx, length) ->
    throw new R.TypeError.new() if idx is null
    size = @__size__()

    # TODO: implement ranges

    if idx?.is_range?
      range = idx
      range_start = CoerceProto.to_int_native(range.begin())
      range_end   = CoerceProto.to_int_native(range.end()  )
      range_start = range_start + size if range_start < 0

      if range_end < 0
        range_end = range_end + size
      # else if range_end >= size
      #   range_end = size - 1

      range_end   = range_end + 1 unless range.exclude_end()
      range_lenth = range_end - range_start
      return null if range_start > size  or range_start < 0
      return new R.Array(@__native__.slice(range_start, range_end))
    else
      idx = CoerceProto.to_int_native(idx)

    idx = size + idx if idx < 0
    # return @$String('') if is_range and idx.lteq(size) and idx.gt(length)

    if length is undefined
      return null if idx < 0 or idx >= size
      @at(idx)
    else
      length = CoerceProto.to_int_native(length)
      return null if idx < 0 or idx > size or length < 0
      new R.Array(@__native__.slice(idx, length + idx))


  # Deletes the element(s) given by an index (optionally with a length) or by
  # a range. Returns the deleted object (or objects), or null if the index is
  # out of range.
  #
  # @example
  #     a = R([ "a", "b", "c" ])
  #     a.slice_bang(1)     # => "b"
  #     a                   # => ["a", "c"]
  #     a.slice_bang(-1)    # => "c"
  #     a                   # => ["a"]
  #     a.slice_bang(100)   # => null
  #     a                   # => ["a"]
  #
  slice_bang: (idx, length) ->
    throw new R.TypeError.new() if idx is null

    ary  = null
    size = @__size__()

    if idx.is_range?
      range = idx
      ary   = @slice(range)
      rng_start = CoerceProto.to_int_native(range.begin())
      rng_end   = CoerceProto.to_int_native(range.end()  )
      rng_start = rng_start + size if rng_start < 0

      if rng_end < 0
        rng_end = rng_end + size
      else if rng_end >= size
        rng_end >= size

      rng_length = rng_end - rng_start
      rng_length = rng_length + 1 unless range.exclude_end()

      # possible bug? in rubinius rng_end.lteq(size) is rng_end < @total
      if rng_start < size && rng_start >= 0 && rng_end <= size && rng_end >= 0 && rng_length > 0
        @__delete_range(rng_start, rng_length)

    else if length isnt undefined
      idx    = CoerceProto.to_int_native(idx)
      length = CoerceProto.to_int_native(length)

      return null if idx > size
      return new R.Array([]) if length is 0

      ary = @slice(idx, length)
      @__delete_range(idx, length)

    else
      idx = CoerceProto.to_int_native(idx)
      ary = @delete_at(idx)

    ary

  # @private
  __delete_range: (start, length) ->
    size = @__size__()
    return null if start > size or start < 0

    if size < (start + length)
      new_ary = new R.Array([])
    else
      new_ary = @slice(0, start).concat(@slice(start + length, size) || [])

    @replace(new_ary) unless new_ary.__size__() is @__size__()


  # Sorts self. Comparisons for the sort will be done using the <=> operator
  # or using an optional code block. The block implements a comparison between
  # a and b, returning -1, 0, or +1.
  #
  # @see Enumerable#sort_by
  # @note Suboptimally implemented, by replacing it with Enumerable#sort().to_native()
  #
  sort_bang: (block) ->
    @replace @sort(block)

  # Sorts self in place using a set of keys generated by mapping the values in
  # self through the given block.
  #
  # If no block is given, an enumerator is returned instead.
  #
  sort_by_bang: (block) ->
    return @to_enum('sort_by_bang') unless block?.call?
    @replace @sort_by(block)


  # Assumes that self is an array of arrays and transposes the rows and columns.
  #
  # @example
  #     a = R([[1,2], [3,4], [5,6]])
  #     a.transpose()   # => [[1, 3, 5], [2, 4, 6]]
  #
  transpose: ->
    return new R.Array([]) if @empty()

    out = new R.Array([])
    max = null

    # TODO: dogfood
    @each (ary) ->
      ary = CoerceProto.to_ary(ary)
      max ||= ary.size()

      # Catches too-large as well as too-small (for which #fetch would suffice)
      # throw R.IndexError.new("All arrays must be same length") if ary.size != max
      throw R.IndexError.new() unless ary.size().equals(max)

      idx = -1
      len = ary.__size__()
      while ++idx < len
        out.append(new R.Array([])) unless out.at(idx)
        entry = out.at(idx)
        entry.append ary.at(idx)
    out

  # Returns a new array by removing duplicate values in self.
  #
  # @example
  #     a = R([ "a", "a", "b", "b", "c" ])
  #     a.uniq()   # => ["a", "b", "c"]
  #     # Not yet implemented:
  #     c = R([ "a:def", "a:xyz", "b:abc", "b:xyz", "c:jkl" ])
  #     c.uniq (s) -> s[/^\w+/]  #=> [ "a:def", "b:abc", "c:jkl" ]
  #
  # @note Not yet correctly implemented. should use #eql on objects, but uses @include().
  #
  uniq: () ->
    arr = new R.Array([])
    @each (el) ->
      arr.push(el) unless arr.include(el)
    arr

  # Removes duplicate elements from self. Returns null if no changes are made
  # (that is, no duplicates are found).
  #
  # @example
  #     a = R([ "a", "a", "b", "b", "c" ])
  #     a.uniq!   # => ["a", "b", "c"]
  #     b = R([ "a", "b", "c" ])
  #     b.uniq!   # => null
  #     # Not yet implemented:
  #     c = R([ "a:def", "a:xyz", "b:abc", "b:xyz", "c:jkl" ])
  #     c.uniq (s) -> s[/^\w+/]  #=> [ "a:def", "b:abc", "c:jkl" ]
  #
  # @note Not yet correctly implemented. should use #eql on objects, but uses @include().
  #
  uniq_bang: (block) ->
    ary = @uniq()
    if ary.__size__() is @__size__() then null else @replace(ary)


  # Prepends objects to the front of self, moving other elements upwards.
  #
  # @example
  #     a = R([ "b", "c", "d"])
  #     a.unshift("a")   #=> ["a", "b", "c", "d"]
  #     a.unshift(1, 2)  #=> [ 1, 2, "a", "b", "c", "d"]
  #
  unshift: (args...) ->
    @replace(args.concat(@__native__))


  # Set Union—Returns a new array by joining this array with other_ary,
  # removing duplicates.
  #
  #     R([ "a", "b", "c" ]).union [ "c", "d", "a" ]
  #       #=> [ "a", "b", "c", "d" ]
  #
  union: (other) ->
    @plus(other).uniq()


  to_a: ->
    @dup()


  # find a better way for this.
  to_enum: (iter = "each", args...) ->
    new RubyJS.Enumerator(this, iter, args)


  to_ary: () -> this


  # Returns an array containing the elements in self corresponding to the
  # given selector(s). The selectors may be either integer indices or ranges.
  # See also Array#select.
  #
  # @example
  #     a = R(['a', 'b', 'c', 'd', 'e', 'f'])
  #     a.values_at(1, 3, 5)
  #     a.values_at(1, 3, 5, 7)
  #     a.values_at(-1, -3, -5, -7)
  #     a.values_at(1..3, 2...5)
  #
  # @todo not working with ranges
  #
  values_at: (args...) ->
    ary = for idx in args
      @at(CoerceProto.to_int_native(idx)) || null

    new R.Array(ary)


  # ---- Aliases --------------------------------------------------------------

  @__add_default_aliases__(@prototype)

  # @alias collect_bang
  map_bang:     @prototype.collect_bang

  # @alias find_index
  index:        @prototype.find_index

  # @alias each
  each_for:     @prototype.each


  # @alias union
  '|':          @prototype.union

  to_s:         @prototype.inspect

  # @alias &
  intersection: @prototype['&']


  deleteAt:     @prototype.delete_at
  deleteIf:     @prototype.delete_if
  dropWhile:    @prototype.drop_while
  eachIndex:    @prototype.each_index
  equalValue:   @prototype.equal_value
  findIndex:    @prototype.find_index
  intersection: @prototype.intersection
  keepIf:       @prototype.keep_if
  reverse_each: @prototype.reverse_each
  sortBy:       @prototype.sort_by
  takeWhile:    @prototype.take_while
  toA:          @prototype.to_a
  toAry:        @prototype.to_ary
  toS:          @prototype.to_s
  tryConvert:   @prototype.try_convert
  valuesAt:     @prototype.values_at

  # ---- Private --------------------------------------------------------------

  __native_array_with__: (size, obj) ->
    ary = nativeArray(CoerceProto.to_int_native(size))
    idx = -1
    while ++idx < size
      ary[idx] = obj
    ary
